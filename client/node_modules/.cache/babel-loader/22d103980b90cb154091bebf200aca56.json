{"ast":null,"code":"import _classCallCheck from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _get from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // Universal IO Loader, implemented by adding Range header in xhr's request header\n\nvar RangeLoader = /*#__PURE__*/function (_BaseLoader) {\n  _inherits(RangeLoader, _BaseLoader);\n\n  var _super = _createSuper(RangeLoader);\n\n  _createClass(RangeLoader, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com', true);\n        xhr.responseType = 'arraybuffer';\n        return xhr.responseType === 'arraybuffer';\n      } catch (e) {\n        Log.w('RangeLoader', e.message);\n        return false;\n      }\n    }\n  }]);\n\n  function RangeLoader(seekHandler, config) {\n    var _this;\n\n    _classCallCheck(this, RangeLoader);\n\n    _this = _super.call(this, 'xhr-range-loader');\n    _this.TAG = 'RangeLoader';\n    _this._seekHandler = seekHandler;\n    _this._config = config;\n    _this._needStash = false;\n    _this._chunkSizeKBList = [128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192];\n    _this._currentChunkSizeKB = 384;\n    _this._currentSpeedNormalized = 0;\n    _this._zeroSpeedChunkCount = 0;\n    _this._xhr = null;\n    _this._speedSampler = new SpeedSampler();\n    _this._requestAbort = false;\n    _this._waitForTotalLength = false;\n    _this._totalLengthReceived = false;\n    _this._currentRequestURL = null;\n    _this._currentRedirectedURL = null;\n    _this._currentRequestRange = null;\n    _this._totalLength = null; // size of the entire file\n\n    _this._contentLength = null; // Content-Length of entire request range\n\n    _this._receivedLength = 0; // total received bytes\n\n    _this._lastTimeLoaded = 0; // received bytes of current request sub-range\n\n    return _this;\n  }\n\n  _createClass(RangeLoader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.isWorking()) {\n        this.abort();\n      }\n\n      if (this._xhr) {\n        this._xhr.onreadystatechange = null;\n        this._xhr.onprogress = null;\n        this._xhr.onload = null;\n        this._xhr.onerror = null;\n        this._xhr = null;\n      }\n\n      _get(_getPrototypeOf(RangeLoader.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(dataSource, range) {\n      this._dataSource = dataSource;\n      this._range = range;\n      this._status = LoaderStatus.kConnecting;\n      var useRefTotalLength = false;\n\n      if (this._dataSource.filesize != undefined && this._dataSource.filesize !== 0) {\n        useRefTotalLength = true;\n        this._totalLength = this._dataSource.filesize;\n      }\n\n      if (!this._totalLengthReceived && !useRefTotalLength) {\n        // We need total filesize\n        this._waitForTotalLength = true;\n\n        this._internalOpen(this._dataSource, {\n          from: 0,\n          to: -1\n        });\n      } else {\n        // We have filesize, start loading\n        this._openSubRange();\n      }\n    }\n  }, {\n    key: \"_openSubRange\",\n    value: function _openSubRange() {\n      var chunkSize = this._currentChunkSizeKB * 1024;\n      var from = this._range.from + this._receivedLength;\n      var to = from + chunkSize;\n\n      if (this._contentLength != null) {\n        if (to - this._range.from >= this._contentLength) {\n          to = this._range.from + this._contentLength - 1;\n        }\n      }\n\n      this._currentRequestRange = {\n        from: from,\n        to: to\n      };\n\n      this._internalOpen(this._dataSource, this._currentRequestRange);\n    }\n  }, {\n    key: \"_internalOpen\",\n    value: function _internalOpen(dataSource, range) {\n      this._lastTimeLoaded = 0;\n      var sourceURL = dataSource.url;\n\n      if (this._config.reuseRedirectedURL) {\n        if (this._currentRedirectedURL != undefined) {\n          sourceURL = this._currentRedirectedURL;\n        } else if (dataSource.redirectedURL != undefined) {\n          sourceURL = dataSource.redirectedURL;\n        }\n      }\n\n      var seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n      this._currentRequestURL = seekConfig.url;\n      var xhr = this._xhr = new XMLHttpRequest();\n      xhr.open('GET', seekConfig.url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n      xhr.onprogress = this._onProgress.bind(this);\n      xhr.onload = this._onLoad.bind(this);\n      xhr.onerror = this._onXhrError.bind(this);\n\n      if (dataSource.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      if (typeof seekConfig.headers === 'object') {\n        var headers = seekConfig.headers;\n\n        for (var key in headers) {\n          if (headers.hasOwnProperty(key)) {\n            xhr.setRequestHeader(key, headers[key]);\n          }\n        }\n      } // add additional headers\n\n\n      if (typeof this._config.headers === 'object') {\n        var _headers = this._config.headers;\n\n        for (var _key in _headers) {\n          if (_headers.hasOwnProperty(_key)) {\n            xhr.setRequestHeader(_key, _headers[_key]);\n          }\n        }\n      }\n\n      xhr.send();\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._requestAbort = true;\n\n      this._internalAbort();\n\n      this._status = LoaderStatus.kComplete;\n    }\n  }, {\n    key: \"_internalAbort\",\n    value: function _internalAbort() {\n      if (this._xhr) {\n        this._xhr.onreadystatechange = null;\n        this._xhr.onprogress = null;\n        this._xhr.onload = null;\n        this._xhr.onerror = null;\n\n        this._xhr.abort();\n\n        this._xhr = null;\n      }\n    }\n  }, {\n    key: \"_onReadyStateChange\",\n    value: function _onReadyStateChange(e) {\n      var xhr = e.target;\n\n      if (xhr.readyState === 2) {\n        // HEADERS_RECEIVED\n        if (xhr.responseURL != undefined) {\n          // if the browser support this property\n          var redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n          if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n            this._currentRedirectedURL = redirectedURL;\n\n            if (this._onURLRedirect) {\n              this._onURLRedirect(redirectedURL);\n            }\n          }\n        }\n\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          if (this._waitForTotalLength) {\n            return;\n          }\n\n          this._status = LoaderStatus.kBuffering;\n        } else {\n          this._status = LoaderStatus.kError;\n\n          if (this._onError) {\n            this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n              code: xhr.status,\n              msg: xhr.statusText\n            });\n          } else {\n            throw new RuntimeException('RangeLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(e) {\n      if (this._status === LoaderStatus.kError) {\n        // Ignore error response\n        return;\n      }\n\n      if (this._contentLength === null) {\n        var openNextRange = false;\n\n        if (this._waitForTotalLength) {\n          this._waitForTotalLength = false;\n          this._totalLengthReceived = true;\n          openNextRange = true;\n          var total = e.total;\n\n          this._internalAbort();\n\n          if (total != null & total !== 0) {\n            this._totalLength = total;\n          }\n        } // calculate currrent request range's contentLength\n\n\n        if (this._range.to === -1) {\n          this._contentLength = this._totalLength - this._range.from;\n        } else {\n          // to !== -1\n          this._contentLength = this._range.to - this._range.from + 1;\n        }\n\n        if (openNextRange) {\n          this._openSubRange();\n\n          return;\n        }\n\n        if (this._onContentLengthKnown) {\n          this._onContentLengthKnown(this._contentLength);\n        }\n      }\n\n      var delta = e.loaded - this._lastTimeLoaded;\n      this._lastTimeLoaded = e.loaded;\n\n      this._speedSampler.addBytes(delta);\n    }\n  }, {\n    key: \"_normalizeSpeed\",\n    value: function _normalizeSpeed(input) {\n      var list = this._chunkSizeKBList;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (input < list[0]) {\n        return list[0];\n      }\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n          return list[mid];\n        } else if (list[mid] < input) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n    }\n  }, {\n    key: \"_onLoad\",\n    value: function _onLoad(e) {\n      if (this._status === LoaderStatus.kError) {\n        // Ignore error response\n        return;\n      }\n\n      if (this._waitForTotalLength) {\n        this._waitForTotalLength = false;\n        return;\n      }\n\n      this._lastTimeLoaded = 0;\n      var KBps = this._speedSampler.lastSecondKBps;\n\n      if (KBps === 0) {\n        this._zeroSpeedChunkCount++;\n\n        if (this._zeroSpeedChunkCount >= 3) {\n          // Try get currentKBps after 3 chunks\n          KBps = this._speedSampler.currentKBps;\n        }\n      }\n\n      if (KBps !== 0) {\n        var normalized = this._normalizeSpeed(KBps);\n\n        if (this._currentSpeedNormalized !== normalized) {\n          this._currentSpeedNormalized = normalized;\n          this._currentChunkSizeKB = normalized;\n        }\n      }\n\n      var chunk = e.target.response;\n      var byteStart = this._range.from + this._receivedLength;\n      this._receivedLength += chunk.byteLength;\n      var reportComplete = false;\n\n      if (this._contentLength != null && this._receivedLength < this._contentLength) {\n        // continue load next chunk\n        this._openSubRange();\n      } else {\n        reportComplete = true;\n      } // dispatch received chunk\n\n\n      if (this._onDataArrival) {\n        this._onDataArrival(chunk, byteStart, this._receivedLength);\n      }\n\n      if (reportComplete) {\n        this._status = LoaderStatus.kComplete;\n\n        if (this._onComplete) {\n          this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n        }\n      }\n    }\n  }, {\n    key: \"_onXhrError\",\n    value: function _onXhrError(e) {\n      this._status = LoaderStatus.kError;\n      var type = 0;\n      var info = null;\n\n      if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength) {\n        type = LoaderErrors.EARLY_EOF;\n        info = {\n          code: -1,\n          msg: 'RangeLoader meet Early-Eof'\n        };\n      } else {\n        type = LoaderErrors.EXCEPTION;\n        info = {\n          code: -1,\n          msg: e.constructor.name + ' ' + e.type\n        };\n      }\n\n      if (this._onError) {\n        this._onError(type, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }, {\n    key: \"currentSpeed\",\n    get: function get() {\n      return this._speedSampler.lastSecondKBps;\n    }\n  }]);\n\n  return RangeLoader;\n}(BaseLoader);\n\nexport default RangeLoader;","map":{"version":3,"sources":["/Users/mitchlew/Documents/Streaming/streams/client/node_modules/flv.js/src/io/xhr-range-loader.js"],"names":["Log","SpeedSampler","BaseLoader","LoaderStatus","LoaderErrors","RuntimeException","RangeLoader","xhr","XMLHttpRequest","open","responseType","e","w","message","seekHandler","config","TAG","_seekHandler","_config","_needStash","_chunkSizeKBList","_currentChunkSizeKB","_currentSpeedNormalized","_zeroSpeedChunkCount","_xhr","_speedSampler","_requestAbort","_waitForTotalLength","_totalLengthReceived","_currentRequestURL","_currentRedirectedURL","_currentRequestRange","_totalLength","_contentLength","_receivedLength","_lastTimeLoaded","isWorking","abort","onreadystatechange","onprogress","onload","onerror","dataSource","range","_dataSource","_range","_status","kConnecting","useRefTotalLength","filesize","undefined","_internalOpen","from","to","_openSubRange","chunkSize","sourceURL","url","reuseRedirectedURL","redirectedURL","seekConfig","getConfig","_onReadyStateChange","bind","_onProgress","_onLoad","_onXhrError","withCredentials","headers","key","hasOwnProperty","setRequestHeader","send","_internalAbort","kComplete","target","readyState","responseURL","removeURLParameters","_onURLRedirect","status","kBuffering","kError","_onError","HTTP_STATUS_CODE_INVALID","code","msg","statusText","openNextRange","total","_onContentLengthKnown","delta","loaded","addBytes","input","list","last","length","mid","lbound","ubound","Math","floor","KBps","lastSecondKBps","currentKBps","normalized","_normalizeSpeed","chunk","response","byteStart","byteLength","reportComplete","_onDataArrival","_onComplete","type","info","EARLY_EOF","EXCEPTION","constructor","name"],"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;AAkBA,OAAOA,GAAP,MAAgB,oBAAhB;AACA,OAAOC,YAAP,MAAyB,oBAAzB;AACA,SAAQC,UAAR,EAAoBC,YAApB,EAAkCC,YAAlC,QAAqD,aAArD;AACA,SAAQC,gBAAR,QAA+B,uBAA/B,C,CAEA;;IACMC,W;;;;;;;kCAEmB;AACjB,UAAI;AACA,YAAIC,GAAG,GAAG,IAAIC,cAAJ,EAAV;AACAD,QAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgB,qBAAhB,EAAuC,IAAvC;AACAF,QAAAA,GAAG,CAACG,YAAJ,GAAmB,aAAnB;AACA,eAAQH,GAAG,CAACG,YAAJ,KAAqB,aAA7B;AACH,OALD,CAKE,OAAOC,CAAP,EAAU;AACRX,QAAAA,GAAG,CAACY,CAAJ,CAAM,aAAN,EAAqBD,CAAC,CAACE,OAAvB;AACA,eAAO,KAAP;AACH;AACJ;;;AAED,uBAAYC,WAAZ,EAAyBC,MAAzB,EAAiC;AAAA;;AAAA;;AAC7B,8BAAM,kBAAN;AACA,UAAKC,GAAL,GAAW,aAAX;AAEA,UAAKC,YAAL,GAAoBH,WAApB;AACA,UAAKI,OAAL,GAAeH,MAAf;AACA,UAAKI,UAAL,GAAkB,KAAlB;AAEA,UAAKC,gBAAL,GAAwB,CACpB,GADoB,EACf,GADe,EACV,GADU,EACL,GADK,EACA,GADA,EACK,IADL,EACW,IADX,EACiB,IADjB,EACuB,IADvB,EAC6B,IAD7B,EACmC,IADnC,EACyC,IADzC,EAC+C,IAD/C,EACqD,IADrD,CAAxB;AAGA,UAAKC,mBAAL,GAA2B,GAA3B;AACA,UAAKC,uBAAL,GAA+B,CAA/B;AACA,UAAKC,oBAAL,GAA4B,CAA5B;AAEA,UAAKC,IAAL,GAAY,IAAZ;AACA,UAAKC,aAAL,GAAqB,IAAIxB,YAAJ,EAArB;AAEA,UAAKyB,aAAL,GAAqB,KAArB;AACA,UAAKC,mBAAL,GAA2B,KAA3B;AACA,UAAKC,oBAAL,GAA4B,KAA5B;AAEA,UAAKC,kBAAL,GAA0B,IAA1B;AACA,UAAKC,qBAAL,GAA6B,IAA7B;AACA,UAAKC,oBAAL,GAA4B,IAA5B;AACA,UAAKC,YAAL,GAAoB,IAApB,CAzB6B,CAyBF;;AAC3B,UAAKC,cAAL,GAAsB,IAAtB,CA1B6B,CA0BA;;AAC7B,UAAKC,eAAL,GAAuB,CAAvB,CA3B6B,CA2BF;;AAC3B,UAAKC,eAAL,GAAuB,CAAvB,CA5B6B,CA4BF;;AA5BE;AA6BhC;;;;8BAES;AACN,UAAI,KAAKC,SAAL,EAAJ,EAAsB;AAClB,aAAKC,KAAL;AACH;;AACD,UAAI,KAAKb,IAAT,EAAe;AACX,aAAKA,IAAL,CAAUc,kBAAV,GAA+B,IAA/B;AACA,aAAKd,IAAL,CAAUe,UAAV,GAAuB,IAAvB;AACA,aAAKf,IAAL,CAAUgB,MAAV,GAAmB,IAAnB;AACA,aAAKhB,IAAL,CAAUiB,OAAV,GAAoB,IAApB;AACA,aAAKjB,IAAL,GAAY,IAAZ;AACH;;AACD;AACH;;;yBAMIkB,U,EAAYC,K,EAAO;AACpB,WAAKC,WAAL,GAAmBF,UAAnB;AACA,WAAKG,MAAL,GAAcF,KAAd;AACA,WAAKG,OAAL,GAAe3C,YAAY,CAAC4C,WAA5B;AAEA,UAAIC,iBAAiB,GAAG,KAAxB;;AACA,UAAI,KAAKJ,WAAL,CAAiBK,QAAjB,IAA6BC,SAA7B,IAA0C,KAAKN,WAAL,CAAiBK,QAAjB,KAA8B,CAA5E,EAA+E;AAC3ED,QAAAA,iBAAiB,GAAG,IAApB;AACA,aAAKhB,YAAL,GAAoB,KAAKY,WAAL,CAAiBK,QAArC;AACH;;AAED,UAAI,CAAC,KAAKrB,oBAAN,IAA8B,CAACoB,iBAAnC,EAAsD;AAClD;AACA,aAAKrB,mBAAL,GAA2B,IAA3B;;AACA,aAAKwB,aAAL,CAAmB,KAAKP,WAAxB,EAAqC;AAACQ,UAAAA,IAAI,EAAE,CAAP;AAAUC,UAAAA,EAAE,EAAE,CAAC;AAAf,SAArC;AACH,OAJD,MAIO;AACH;AACA,aAAKC,aAAL;AACH;AACJ;;;oCAEe;AACZ,UAAIC,SAAS,GAAG,KAAKlC,mBAAL,GAA2B,IAA3C;AAEA,UAAI+B,IAAI,GAAG,KAAKP,MAAL,CAAYO,IAAZ,GAAmB,KAAKlB,eAAnC;AACA,UAAImB,EAAE,GAAGD,IAAI,GAAGG,SAAhB;;AAEA,UAAI,KAAKtB,cAAL,IAAuB,IAA3B,EAAiC;AAC7B,YAAIoB,EAAE,GAAG,KAAKR,MAAL,CAAYO,IAAjB,IAAyB,KAAKnB,cAAlC,EAAkD;AAC9CoB,UAAAA,EAAE,GAAG,KAAKR,MAAL,CAAYO,IAAZ,GAAmB,KAAKnB,cAAxB,GAAyC,CAA9C;AACH;AACJ;;AAED,WAAKF,oBAAL,GAA4B;AAACqB,QAAAA,IAAI,EAAJA,IAAD;AAAOC,QAAAA,EAAE,EAAFA;AAAP,OAA5B;;AACA,WAAKF,aAAL,CAAmB,KAAKP,WAAxB,EAAqC,KAAKb,oBAA1C;AACH;;;kCAEaW,U,EAAYC,K,EAAO;AAC7B,WAAKR,eAAL,GAAuB,CAAvB;AAEA,UAAIqB,SAAS,GAAGd,UAAU,CAACe,GAA3B;;AACA,UAAI,KAAKvC,OAAL,CAAawC,kBAAjB,EAAqC;AACjC,YAAI,KAAK5B,qBAAL,IAA8BoB,SAAlC,EAA6C;AACzCM,UAAAA,SAAS,GAAG,KAAK1B,qBAAjB;AACH,SAFD,MAEO,IAAIY,UAAU,CAACiB,aAAX,IAA4BT,SAAhC,EAA2C;AAC9CM,UAAAA,SAAS,GAAGd,UAAU,CAACiB,aAAvB;AACH;AACJ;;AAED,UAAIC,UAAU,GAAG,KAAK3C,YAAL,CAAkB4C,SAAlB,CAA4BL,SAA5B,EAAuCb,KAAvC,CAAjB;;AACA,WAAKd,kBAAL,GAA0B+B,UAAU,CAACH,GAArC;AAEA,UAAIlD,GAAG,GAAG,KAAKiB,IAAL,GAAY,IAAIhB,cAAJ,EAAtB;AACAD,MAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgBmD,UAAU,CAACH,GAA3B,EAAgC,IAAhC;AACAlD,MAAAA,GAAG,CAACG,YAAJ,GAAmB,aAAnB;AACAH,MAAAA,GAAG,CAAC+B,kBAAJ,GAAyB,KAAKwB,mBAAL,CAAyBC,IAAzB,CAA8B,IAA9B,CAAzB;AACAxD,MAAAA,GAAG,CAACgC,UAAJ,GAAiB,KAAKyB,WAAL,CAAiBD,IAAjB,CAAsB,IAAtB,CAAjB;AACAxD,MAAAA,GAAG,CAACiC,MAAJ,GAAa,KAAKyB,OAAL,CAAaF,IAAb,CAAkB,IAAlB,CAAb;AACAxD,MAAAA,GAAG,CAACkC,OAAJ,GAAc,KAAKyB,WAAL,CAAiBH,IAAjB,CAAsB,IAAtB,CAAd;;AAEA,UAAIrB,UAAU,CAACyB,eAAf,EAAgC;AAC5B5D,QAAAA,GAAG,CAAC4D,eAAJ,GAAsB,IAAtB;AACH;;AAED,UAAI,OAAOP,UAAU,CAACQ,OAAlB,KAA8B,QAAlC,EAA4C;AACxC,YAAIA,OAAO,GAAGR,UAAU,CAACQ,OAAzB;;AAEA,aAAK,IAAIC,GAAT,IAAgBD,OAAhB,EAAyB;AACrB,cAAIA,OAAO,CAACE,cAAR,CAAuBD,GAAvB,CAAJ,EAAiC;AAC7B9D,YAAAA,GAAG,CAACgE,gBAAJ,CAAqBF,GAArB,EAA0BD,OAAO,CAACC,GAAD,CAAjC;AACH;AACJ;AACJ,OAnC4B,CAqC7B;;;AACA,UAAI,OAAO,KAAKnD,OAAL,CAAakD,OAApB,KAAgC,QAApC,EAA8C;AAC1C,YAAIA,QAAO,GAAG,KAAKlD,OAAL,CAAakD,OAA3B;;AAEA,aAAK,IAAIC,IAAT,IAAgBD,QAAhB,EAAyB;AACrB,cAAIA,QAAO,CAACE,cAAR,CAAuBD,IAAvB,CAAJ,EAAiC;AAC7B9D,YAAAA,GAAG,CAACgE,gBAAJ,CAAqBF,IAArB,EAA0BD,QAAO,CAACC,IAAD,CAAjC;AACH;AACJ;AACJ;;AAED9D,MAAAA,GAAG,CAACiE,IAAJ;AACH;;;4BAEO;AACJ,WAAK9C,aAAL,GAAqB,IAArB;;AACA,WAAK+C,cAAL;;AACA,WAAK3B,OAAL,GAAe3C,YAAY,CAACuE,SAA5B;AACH;;;qCAEgB;AACb,UAAI,KAAKlD,IAAT,EAAe;AACX,aAAKA,IAAL,CAAUc,kBAAV,GAA+B,IAA/B;AACA,aAAKd,IAAL,CAAUe,UAAV,GAAuB,IAAvB;AACA,aAAKf,IAAL,CAAUgB,MAAV,GAAmB,IAAnB;AACA,aAAKhB,IAAL,CAAUiB,OAAV,GAAoB,IAApB;;AACA,aAAKjB,IAAL,CAAUa,KAAV;;AACA,aAAKb,IAAL,GAAY,IAAZ;AACH;AACJ;;;wCAEmBb,C,EAAG;AACnB,UAAIJ,GAAG,GAAGI,CAAC,CAACgE,MAAZ;;AAEA,UAAIpE,GAAG,CAACqE,UAAJ,KAAmB,CAAvB,EAA0B;AAAG;AACzB,YAAIrE,GAAG,CAACsE,WAAJ,IAAmB3B,SAAvB,EAAkC;AAAG;AACjC,cAAIS,aAAa,GAAG,KAAK1C,YAAL,CAAkB6D,mBAAlB,CAAsCvE,GAAG,CAACsE,WAA1C,CAApB;;AACA,cAAItE,GAAG,CAACsE,WAAJ,KAAoB,KAAKhD,kBAAzB,IAA+C8B,aAAa,KAAK,KAAK7B,qBAA1E,EAAiG;AAC7F,iBAAKA,qBAAL,GAA6B6B,aAA7B;;AACA,gBAAI,KAAKoB,cAAT,EAAyB;AACrB,mBAAKA,cAAL,CAAoBpB,aAApB;AACH;AACJ;AACJ;;AAED,YAAKpD,GAAG,CAACyE,MAAJ,IAAc,GAAd,IAAqBzE,GAAG,CAACyE,MAAJ,IAAc,GAAxC,EAA8C;AAC1C,cAAI,KAAKrD,mBAAT,EAA8B;AAC1B;AACH;;AACD,eAAKmB,OAAL,GAAe3C,YAAY,CAAC8E,UAA5B;AACH,SALD,MAKO;AACH,eAAKnC,OAAL,GAAe3C,YAAY,CAAC+E,MAA5B;;AACA,cAAI,KAAKC,QAAT,EAAmB;AACf,iBAAKA,QAAL,CAAc/E,YAAY,CAACgF,wBAA3B,EAAqD;AAACC,cAAAA,IAAI,EAAE9E,GAAG,CAACyE,MAAX;AAAmBM,cAAAA,GAAG,EAAE/E,GAAG,CAACgF;AAA5B,aAArD;AACH,WAFD,MAEO;AACH,kBAAM,IAAIlF,gBAAJ,CAAqB,qCAAqCE,GAAG,CAACyE,MAAzC,GAAkD,GAAlD,GAAwDzE,GAAG,CAACgF,UAAjF,CAAN;AACH;AACJ;AACJ;AACJ;;;gCAEW5E,C,EAAG;AACX,UAAI,KAAKmC,OAAL,KAAiB3C,YAAY,CAAC+E,MAAlC,EAA0C;AACtC;AACA;AACH;;AAED,UAAI,KAAKjD,cAAL,KAAwB,IAA5B,EAAkC;AAC9B,YAAIuD,aAAa,GAAG,KAApB;;AAEA,YAAI,KAAK7D,mBAAT,EAA8B;AAC1B,eAAKA,mBAAL,GAA2B,KAA3B;AACA,eAAKC,oBAAL,GAA4B,IAA5B;AACA4D,UAAAA,aAAa,GAAG,IAAhB;AAEA,cAAIC,KAAK,GAAG9E,CAAC,CAAC8E,KAAd;;AACA,eAAKhB,cAAL;;AACA,cAAIgB,KAAK,IAAI,IAAT,GAAgBA,KAAK,KAAK,CAA9B,EAAiC;AAC7B,iBAAKzD,YAAL,GAAoByD,KAApB;AACH;AACJ,SAb6B,CAe9B;;;AACA,YAAI,KAAK5C,MAAL,CAAYQ,EAAZ,KAAmB,CAAC,CAAxB,EAA2B;AACvB,eAAKpB,cAAL,GAAsB,KAAKD,YAAL,GAAoB,KAAKa,MAAL,CAAYO,IAAtD;AACH,SAFD,MAEO;AAAG;AACN,eAAKnB,cAAL,GAAsB,KAAKY,MAAL,CAAYQ,EAAZ,GAAiB,KAAKR,MAAL,CAAYO,IAA7B,GAAoC,CAA1D;AACH;;AAED,YAAIoC,aAAJ,EAAmB;AACf,eAAKlC,aAAL;;AACA;AACH;;AACD,YAAI,KAAKoC,qBAAT,EAAgC;AAC5B,eAAKA,qBAAL,CAA2B,KAAKzD,cAAhC;AACH;AACJ;;AAED,UAAI0D,KAAK,GAAGhF,CAAC,CAACiF,MAAF,GAAW,KAAKzD,eAA5B;AACA,WAAKA,eAAL,GAAuBxB,CAAC,CAACiF,MAAzB;;AACA,WAAKnE,aAAL,CAAmBoE,QAAnB,CAA4BF,KAA5B;AACH;;;oCAEeG,K,EAAO;AACnB,UAAIC,IAAI,GAAG,KAAK3E,gBAAhB;AACA,UAAI4E,IAAI,GAAGD,IAAI,CAACE,MAAL,GAAc,CAAzB;AACA,UAAIC,GAAG,GAAG,CAAV;AACA,UAAIC,MAAM,GAAG,CAAb;AACA,UAAIC,MAAM,GAAGJ,IAAb;;AAEA,UAAIF,KAAK,GAAGC,IAAI,CAAC,CAAD,CAAhB,EAAqB;AACjB,eAAOA,IAAI,CAAC,CAAD,CAAX;AACH;;AAED,aAAOI,MAAM,IAAIC,MAAjB,EAAyB;AACrBF,QAAAA,GAAG,GAAGC,MAAM,GAAGE,IAAI,CAACC,KAAL,CAAW,CAACF,MAAM,GAAGD,MAAV,IAAoB,CAA/B,CAAf;;AACA,YAAID,GAAG,KAAKF,IAAR,IAAiBF,KAAK,IAAIC,IAAI,CAACG,GAAD,CAAb,IAAsBJ,KAAK,GAAGC,IAAI,CAACG,GAAG,GAAG,CAAP,CAAvD,EAAmE;AAC/D,iBAAOH,IAAI,CAACG,GAAD,CAAX;AACH,SAFD,MAEO,IAAIH,IAAI,CAACG,GAAD,CAAJ,GAAYJ,KAAhB,EAAuB;AAC1BK,UAAAA,MAAM,GAAGD,GAAG,GAAG,CAAf;AACH,SAFM,MAEA;AACHE,UAAAA,MAAM,GAAGF,GAAG,GAAG,CAAf;AACH;AACJ;AACJ;;;4BAEOvF,C,EAAG;AACP,UAAI,KAAKmC,OAAL,KAAiB3C,YAAY,CAAC+E,MAAlC,EAA0C;AACtC;AACA;AACH;;AAED,UAAI,KAAKvD,mBAAT,EAA8B;AAC1B,aAAKA,mBAAL,GAA2B,KAA3B;AACA;AACH;;AAED,WAAKQ,eAAL,GAAuB,CAAvB;AACA,UAAIoE,IAAI,GAAG,KAAK9E,aAAL,CAAmB+E,cAA9B;;AACA,UAAID,IAAI,KAAK,CAAb,EAAgB;AACZ,aAAKhF,oBAAL;;AACA,YAAI,KAAKA,oBAAL,IAA6B,CAAjC,EAAoC;AAChC;AACAgF,UAAAA,IAAI,GAAG,KAAK9E,aAAL,CAAmBgF,WAA1B;AACH;AACJ;;AAED,UAAIF,IAAI,KAAK,CAAb,EAAgB;AACZ,YAAIG,UAAU,GAAG,KAAKC,eAAL,CAAqBJ,IAArB,CAAjB;;AACA,YAAI,KAAKjF,uBAAL,KAAiCoF,UAArC,EAAiD;AAC7C,eAAKpF,uBAAL,GAA+BoF,UAA/B;AACA,eAAKrF,mBAAL,GAA2BqF,UAA3B;AACH;AACJ;;AAED,UAAIE,KAAK,GAAGjG,CAAC,CAACgE,MAAF,CAASkC,QAArB;AACA,UAAIC,SAAS,GAAG,KAAKjE,MAAL,CAAYO,IAAZ,GAAmB,KAAKlB,eAAxC;AACA,WAAKA,eAAL,IAAwB0E,KAAK,CAACG,UAA9B;AAEA,UAAIC,cAAc,GAAG,KAArB;;AAEA,UAAI,KAAK/E,cAAL,IAAuB,IAAvB,IAA+B,KAAKC,eAAL,GAAuB,KAAKD,cAA/D,EAA+E;AAC3E;AACA,aAAKqB,aAAL;AACH,OAHD,MAGO;AACH0D,QAAAA,cAAc,GAAG,IAAjB;AACH,OAxCM,CA0CP;;;AACA,UAAI,KAAKC,cAAT,EAAyB;AACrB,aAAKA,cAAL,CAAoBL,KAApB,EAA2BE,SAA3B,EAAsC,KAAK5E,eAA3C;AACH;;AAED,UAAI8E,cAAJ,EAAoB;AAChB,aAAKlE,OAAL,GAAe3C,YAAY,CAACuE,SAA5B;;AACA,YAAI,KAAKwC,WAAT,EAAsB;AAClB,eAAKA,WAAL,CAAiB,KAAKrE,MAAL,CAAYO,IAA7B,EAAmC,KAAKP,MAAL,CAAYO,IAAZ,GAAmB,KAAKlB,eAAxB,GAA0C,CAA7E;AACH;AACJ;AACJ;;;gCAEWvB,C,EAAG;AACX,WAAKmC,OAAL,GAAe3C,YAAY,CAAC+E,MAA5B;AACA,UAAIiC,IAAI,GAAG,CAAX;AACA,UAAIC,IAAI,GAAG,IAAX;;AAEA,UAAI,KAAKnF,cAAL,IAAuB,KAAKC,eAAL,GAAuB,CAA9C,IACuB,KAAKA,eAAL,GAAuB,KAAKD,cADvD,EACuE;AACnEkF,QAAAA,IAAI,GAAG/G,YAAY,CAACiH,SAApB;AACAD,QAAAA,IAAI,GAAG;AAAC/B,UAAAA,IAAI,EAAE,CAAC,CAAR;AAAWC,UAAAA,GAAG,EAAE;AAAhB,SAAP;AACH,OAJD,MAIO;AACH6B,QAAAA,IAAI,GAAG/G,YAAY,CAACkH,SAApB;AACAF,QAAAA,IAAI,GAAG;AAAC/B,UAAAA,IAAI,EAAE,CAAC,CAAR;AAAWC,UAAAA,GAAG,EAAE3E,CAAC,CAAC4G,WAAF,CAAcC,IAAd,GAAqB,GAArB,GAA2B7G,CAAC,CAACwG;AAA7C,SAAP;AACH;;AAED,UAAI,KAAKhC,QAAT,EAAmB;AACf,aAAKA,QAAL,CAAcgC,IAAd,EAAoBC,IAApB;AACH,OAFD,MAEO;AACH,cAAM,IAAI/G,gBAAJ,CAAqB+G,IAAI,CAAC9B,GAA1B,CAAN;AACH;AACJ;;;wBAtRkB;AACf,aAAO,KAAK7D,aAAL,CAAmB+E,cAA1B;AACH;;;;EA7DqBtG,U;;AAqV1B,eAAeI,WAAf","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport {BaseLoader, LoaderStatus, LoaderErrors} from './loader.js';\nimport {RuntimeException} from '../utils/exception.js';\n\n// Universal IO Loader, implemented by adding Range header in xhr's request header\nclass RangeLoader extends BaseLoader {\n\n    static isSupported() {\n        try {\n            let xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            xhr.responseType = 'arraybuffer';\n            return (xhr.responseType === 'arraybuffer');\n        } catch (e) {\n            Log.w('RangeLoader', e.message);\n            return false;\n        }\n    }\n\n    constructor(seekHandler, config) {\n        super('xhr-range-loader');\n        this.TAG = 'RangeLoader';\n\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n\n        this._chunkSizeKBList = [\n            128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192\n        ];\n        this._currentChunkSizeKB = 384;\n        this._currentSpeedNormalized = 0;\n        this._zeroSpeedChunkCount = 0;\n\n        this._xhr = null;\n        this._speedSampler = new SpeedSampler();\n\n        this._requestAbort = false;\n        this._waitForTotalLength = false;\n        this._totalLengthReceived = false;\n\n        this._currentRequestURL = null;\n        this._currentRedirectedURL = null;\n        this._currentRequestRange = null;\n        this._totalLength = null;  // size of the entire file\n        this._contentLength = null;  // Content-Length of entire request range\n        this._receivedLength = 0;  // total received bytes\n        this._lastTimeLoaded = 0;  // received bytes of current request sub-range\n    }\n\n    destroy() {\n        if (this.isWorking()) {\n            this.abort();\n        }\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr.onprogress = null;\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr = null;\n        }\n        super.destroy();\n    }\n\n    get currentSpeed() {\n        return this._speedSampler.lastSecondKBps;\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._status = LoaderStatus.kConnecting;\n\n        let useRefTotalLength = false;\n        if (this._dataSource.filesize != undefined && this._dataSource.filesize !== 0) {\n            useRefTotalLength = true;\n            this._totalLength = this._dataSource.filesize;\n        }\n\n        if (!this._totalLengthReceived && !useRefTotalLength) {\n            // We need total filesize\n            this._waitForTotalLength = true;\n            this._internalOpen(this._dataSource, {from: 0, to: -1});\n        } else {\n            // We have filesize, start loading\n            this._openSubRange();\n        }\n    }\n\n    _openSubRange() {\n        let chunkSize = this._currentChunkSizeKB * 1024;\n\n        let from = this._range.from + this._receivedLength;\n        let to = from + chunkSize;\n\n        if (this._contentLength != null) {\n            if (to - this._range.from >= this._contentLength) {\n                to = this._range.from + this._contentLength - 1;\n            }\n        }\n\n        this._currentRequestRange = {from, to};\n        this._internalOpen(this._dataSource, this._currentRequestRange);\n    }\n\n    _internalOpen(dataSource, range) {\n        this._lastTimeLoaded = 0;\n\n        let sourceURL = dataSource.url;\n        if (this._config.reuseRedirectedURL) {\n            if (this._currentRedirectedURL != undefined) {\n                sourceURL = this._currentRedirectedURL;\n            } else if (dataSource.redirectedURL != undefined) {\n                sourceURL = dataSource.redirectedURL;\n            }\n        }\n\n        let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n        this._currentRequestURL = seekConfig.url;\n\n        let xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', seekConfig.url, true);\n        xhr.responseType = 'arraybuffer';\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onprogress = this._onProgress.bind(this);\n        xhr.onload = this._onLoad.bind(this);\n        xhr.onerror = this._onXhrError.bind(this);\n\n        if (dataSource.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (typeof seekConfig.headers === 'object') {\n            let headers = seekConfig.headers;\n\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        // add additional headers\n        if (typeof this._config.headers === 'object') {\n            let headers = this._config.headers;\n\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        xhr.send();\n    }\n\n    abort() {\n        this._requestAbort = true;\n        this._internalAbort();\n        this._status = LoaderStatus.kComplete;\n    }\n\n    _internalAbort() {\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr.onprogress = null;\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr.abort();\n            this._xhr = null;\n        }\n    }\n\n    _onReadyStateChange(e) {\n        let xhr = e.target;\n\n        if (xhr.readyState === 2) {  // HEADERS_RECEIVED\n            if (xhr.responseURL != undefined) {  // if the browser support this property\n                let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n                if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n                    this._currentRedirectedURL = redirectedURL;\n                    if (this._onURLRedirect) {\n                        this._onURLRedirect(redirectedURL);\n                    }\n                }\n            }\n\n            if ((xhr.status >= 200 && xhr.status <= 299)) {\n                if (this._waitForTotalLength) {\n                    return;\n                }\n                this._status = LoaderStatus.kBuffering;\n            } else {\n                this._status = LoaderStatus.kError;\n                if (this._onError) {\n                    this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {code: xhr.status, msg: xhr.statusText});\n                } else {\n                    throw new RuntimeException('RangeLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n                }\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (this._status === LoaderStatus.kError) {\n            // Ignore error response\n            return;\n        }\n\n        if (this._contentLength === null) {\n            let openNextRange = false;\n\n            if (this._waitForTotalLength) {\n                this._waitForTotalLength = false;\n                this._totalLengthReceived = true;\n                openNextRange = true;\n\n                let total = e.total;\n                this._internalAbort();\n                if (total != null & total !== 0) {\n                    this._totalLength = total;\n                }\n            }\n\n            // calculate currrent request range's contentLength\n            if (this._range.to === -1) {\n                this._contentLength = this._totalLength - this._range.from;\n            } else {  // to !== -1\n                this._contentLength = this._range.to - this._range.from + 1;\n            }\n\n            if (openNextRange) {\n                this._openSubRange();\n                return;\n            }\n            if (this._onContentLengthKnown) {\n                this._onContentLengthKnown(this._contentLength);\n            }\n        }\n\n        let delta = e.loaded - this._lastTimeLoaded;\n        this._lastTimeLoaded = e.loaded;\n        this._speedSampler.addBytes(delta);\n    }\n\n    _normalizeSpeed(input) {\n        let list = this._chunkSizeKBList;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (input < list[0]) {\n            return list[0];\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (input >= list[mid] && input < list[mid + 1])) {\n                return list[mid];\n            } else if (list[mid] < input) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n    }\n\n    _onLoad(e) {\n        if (this._status === LoaderStatus.kError) {\n            // Ignore error response\n            return;\n        }\n\n        if (this._waitForTotalLength) {\n            this._waitForTotalLength = false;\n            return;\n        }\n\n        this._lastTimeLoaded = 0;\n        let KBps = this._speedSampler.lastSecondKBps;\n        if (KBps === 0) {\n            this._zeroSpeedChunkCount++;\n            if (this._zeroSpeedChunkCount >= 3) {\n                // Try get currentKBps after 3 chunks\n                KBps = this._speedSampler.currentKBps;\n            }\n        }\n\n        if (KBps !== 0) {\n            let normalized = this._normalizeSpeed(KBps);\n            if (this._currentSpeedNormalized !== normalized) {\n                this._currentSpeedNormalized = normalized;\n                this._currentChunkSizeKB = normalized;\n            }\n        }\n\n        let chunk = e.target.response;\n        let byteStart = this._range.from + this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        let reportComplete = false;\n\n        if (this._contentLength != null && this._receivedLength < this._contentLength) {\n            // continue load next chunk\n            this._openSubRange();\n        } else {\n            reportComplete = true;\n        }\n\n        // dispatch received chunk\n        if (this._onDataArrival) {\n            this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n\n        if (reportComplete) {\n            this._status = LoaderStatus.kComplete;\n            if (this._onComplete) {\n                this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n            }\n        }\n    }\n\n    _onXhrError(e) {\n        this._status = LoaderStatus.kError;\n        let type = 0;\n        let info = null;\n\n        if (this._contentLength && this._receivedLength > 0\n                                && this._receivedLength < this._contentLength) {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: 'RangeLoader meet Early-Eof'};\n        } else {\n            type = LoaderErrors.EXCEPTION;\n            info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n        }\n\n        if (this._onError) {\n            this._onError(type, info);\n        } else {\n            throw new RuntimeException(info.msg);\n        }\n    }\n\n}\n\nexport default RangeLoader;"]},"metadata":{},"sourceType":"module"}