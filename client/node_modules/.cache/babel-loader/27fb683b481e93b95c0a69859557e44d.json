{"ast":null,"code":"import _classCallCheck from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { LoaderStatus, LoaderErrors } from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport { RuntimeException, IllegalStateException, InvalidArgumentException } from '../utils/exception.js';\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n// Manage IO Loaders\n\nvar IOController = /*#__PURE__*/function () {\n  function IOController(dataSource, config, extraData) {\n    _classCallCheck(this, IOController);\n\n    this.TAG = 'IOController';\n    this._config = config;\n    this._extraData = extraData;\n    this._stashInitialSize = 1024 * 384; // default initial size: 384KB\n\n    if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n      // apply from config\n      this._stashInitialSize = config.stashInitialSize;\n    }\n\n    this._stashUsed = 0;\n    this._stashSize = this._stashInitialSize;\n    this._bufferSize = 1024 * 1024 * 3; // initial size: 3MB\n\n    this._stashBuffer = new ArrayBuffer(this._bufferSize);\n    this._stashByteStart = 0;\n    this._enableStash = true;\n\n    if (config.enableStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._seekHandler = null;\n    this._dataSource = dataSource;\n    this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n    this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n    this._totalLength = this._refTotalLength;\n    this._fullRequestFlag = false;\n    this._currentRange = null;\n    this._redirectedURL = null;\n    this._speedNormalized = 0;\n    this._speedSampler = new SpeedSampler();\n    this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n    this._isEarlyEofReconnecting = false;\n    this._paused = false;\n    this._resumeFrom = 0;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n\n    this._selectSeekHandler();\n\n    this._selectLoader();\n\n    this._createLoader();\n  }\n\n  _createClass(IOController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._loader.isWorking()) {\n        this._loader.abort();\n      }\n\n      this._loader.destroy();\n\n      this._loader = null;\n      this._loaderClass = null;\n      this._dataSource = null;\n      this._stashBuffer = null;\n      this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n      this._currentRange = null;\n      this._speedSampler = null;\n      this._isEarlyEofReconnecting = false;\n      this._onDataArrival = null;\n      this._onSeeked = null;\n      this._onError = null;\n      this._onComplete = null;\n      this._onRedirect = null;\n      this._onRecoveredEarlyEof = null;\n      this._extraData = null;\n    }\n  }, {\n    key: \"isWorking\",\n    value: function isWorking() {\n      return this._loader && this._loader.isWorking() && !this._paused;\n    }\n  }, {\n    key: \"isPaused\",\n    value: function isPaused() {\n      return this._paused;\n    }\n  }, {\n    key: \"_selectSeekHandler\",\n    value: function _selectSeekHandler() {\n      var config = this._config;\n\n      if (config.seekType === 'range') {\n        this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n      } else if (config.seekType === 'param') {\n        var paramStart = config.seekParamStart || 'bstart';\n        var paramEnd = config.seekParamEnd || 'bend';\n        this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n      } else if (config.seekType === 'custom') {\n        if (typeof config.customSeekHandler !== 'function') {\n          throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n        }\n\n        this._seekHandler = new config.customSeekHandler();\n      } else {\n        throw new InvalidArgumentException(\"Invalid seekType in config: \".concat(config.seekType));\n      }\n    }\n  }, {\n    key: \"_selectLoader\",\n    value: function _selectLoader() {\n      if (this._config.customLoader != null) {\n        this._loaderClass = this._config.customLoader;\n      } else if (this._isWebSocketURL) {\n        this._loaderClass = WebSocketLoader;\n      } else if (FetchStreamLoader.isSupported()) {\n        this._loaderClass = FetchStreamLoader;\n      } else if (MozChunkedLoader.isSupported()) {\n        this._loaderClass = MozChunkedLoader;\n      } else if (RangeLoader.isSupported()) {\n        this._loaderClass = RangeLoader;\n      } else {\n        throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n      }\n    }\n  }, {\n    key: \"_createLoader\",\n    value: function _createLoader() {\n      this._loader = new this._loaderClass(this._seekHandler, this._config);\n\n      if (this._loader.needStashBuffer === false) {\n        this._enableStash = false;\n      }\n\n      this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n      this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n      this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n      this._loader.onComplete = this._onLoaderComplete.bind(this);\n      this._loader.onError = this._onLoaderError.bind(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(optionalFrom) {\n      this._currentRange = {\n        from: 0,\n        to: -1\n      };\n\n      if (optionalFrom) {\n        this._currentRange.from = optionalFrom;\n      }\n\n      this._speedSampler.reset();\n\n      if (!optionalFrom) {\n        this._fullRequestFlag = true;\n      }\n\n      this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._loader.abort();\n\n      if (this._paused) {\n        this._paused = false;\n        this._resumeFrom = 0;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.isWorking()) {\n        this._loader.abort();\n\n        if (this._stashUsed !== 0) {\n          this._resumeFrom = this._stashByteStart;\n          this._currentRange.to = this._stashByteStart - 1;\n        } else {\n          this._resumeFrom = this._currentRange.to + 1;\n        }\n\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        this._paused = true;\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._paused) {\n        this._paused = false;\n        var bytes = this._resumeFrom;\n        this._resumeFrom = 0;\n\n        this._internalSeek(bytes, true);\n      }\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(bytes) {\n      this._paused = false;\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n\n      this._internalSeek(bytes, true);\n    }\n    /**\n     * When seeking request is from media seeking, unconsumed stash data should be dropped\n     * However, stash data shouldn't be dropped if seeking requested from http reconnection\n     *\n     * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n     */\n\n  }, {\n    key: \"_internalSeek\",\n    value: function _internalSeek(bytes, dropUnconsumed) {\n      if (this._loader.isWorking()) {\n        this._loader.abort();\n      } // dispatch & flush stash buffer before seek\n\n\n      this._flushStashBuffer(dropUnconsumed);\n\n      this._loader.destroy();\n\n      this._loader = null;\n      var requestRange = {\n        from: bytes,\n        to: -1\n      };\n      this._currentRange = {\n        from: requestRange.from,\n        to: -1\n      };\n\n      this._speedSampler.reset();\n\n      this._stashSize = this._stashInitialSize;\n\n      this._createLoader();\n\n      this._loader.open(this._dataSource, requestRange);\n\n      if (this._onSeeked) {\n        this._onSeeked();\n      }\n    }\n  }, {\n    key: \"updateUrl\",\n    value: function updateUrl(url) {\n      if (!url || typeof url !== 'string' || url.length === 0) {\n        throw new InvalidArgumentException('Url must be a non-empty string!');\n      }\n\n      this._dataSource.url = url; // TODO: replace with new url\n    }\n  }, {\n    key: \"_expandBuffer\",\n    value: function _expandBuffer(expectedBytes) {\n      var bufferNewSize = this._stashSize;\n\n      while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n        bufferNewSize *= 2;\n      }\n\n      bufferNewSize += 1024 * 1024 * 1; // bufferSize = stashSize + 1MB\n\n      if (bufferNewSize === this._bufferSize) {\n        return;\n      }\n\n      var newBuffer = new ArrayBuffer(bufferNewSize);\n\n      if (this._stashUsed > 0) {\n        // copy existing data into new buffer\n        var stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n        var stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n        stashNewArray.set(stashOldArray, 0);\n      }\n\n      this._stashBuffer = newBuffer;\n      this._bufferSize = bufferNewSize;\n    }\n  }, {\n    key: \"_normalizeSpeed\",\n    value: function _normalizeSpeed(input) {\n      var list = this._speedNormalizeList;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (input < list[0]) {\n        return list[0];\n      } // binary search\n\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n          return list[mid];\n        } else if (list[mid] < input) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n    }\n  }, {\n    key: \"_adjustStashSize\",\n    value: function _adjustStashSize(normalized) {\n      var stashSizeKB = 0;\n\n      if (this._config.isLive) {\n        // live stream: always use single normalized speed for size of stashSizeKB\n        stashSizeKB = normalized;\n      } else {\n        if (normalized < 512) {\n          stashSizeKB = normalized;\n        } else if (normalized >= 512 && normalized <= 1024) {\n          stashSizeKB = Math.floor(normalized * 1.5);\n        } else {\n          stashSizeKB = normalized * 2;\n        }\n      }\n\n      if (stashSizeKB > 8192) {\n        stashSizeKB = 8192;\n      }\n\n      var bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1; // stashSize + 1MB\n\n      if (this._bufferSize < bufferSize) {\n        this._expandBuffer(bufferSize);\n      }\n\n      this._stashSize = stashSizeKB * 1024;\n    }\n  }, {\n    key: \"_dispatchChunks\",\n    value: function _dispatchChunks(chunks, byteStart) {\n      this._currentRange.to = byteStart + chunks.byteLength - 1;\n      return this._onDataArrival(chunks, byteStart);\n    }\n  }, {\n    key: \"_onURLRedirect\",\n    value: function _onURLRedirect(redirectedURL) {\n      this._redirectedURL = redirectedURL;\n\n      if (this._onRedirect) {\n        this._onRedirect(redirectedURL);\n      }\n    }\n  }, {\n    key: \"_onContentLengthKnown\",\n    value: function _onContentLengthKnown(contentLength) {\n      if (contentLength && this._fullRequestFlag) {\n        this._totalLength = contentLength;\n        this._fullRequestFlag = false;\n      }\n    }\n  }, {\n    key: \"_onLoaderChunkArrival\",\n    value: function _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n      if (!this._onDataArrival) {\n        throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n      }\n\n      if (this._paused) {\n        return;\n      }\n\n      if (this._isEarlyEofReconnecting) {\n        // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n        this._isEarlyEofReconnecting = false;\n\n        if (this._onRecoveredEarlyEof) {\n          this._onRecoveredEarlyEof();\n        }\n      }\n\n      this._speedSampler.addBytes(chunk.byteLength); // adjust stash buffer size according to network speed dynamically\n\n\n      var KBps = this._speedSampler.lastSecondKBps;\n\n      if (KBps !== 0) {\n        var normalized = this._normalizeSpeed(KBps);\n\n        if (this._speedNormalized !== normalized) {\n          this._speedNormalized = normalized;\n\n          this._adjustStashSize(normalized);\n        }\n      }\n\n      if (!this._enableStash) {\n        // disable stash\n        if (this._stashUsed === 0) {\n          // dispatch chunk directly to consumer;\n          // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n          var consumed = this._dispatchChunks(chunk, byteStart);\n\n          if (consumed < chunk.byteLength) {\n            // unconsumed data remain.\n            var remain = chunk.byteLength - consumed;\n\n            if (remain > this._bufferSize) {\n              this._expandBuffer(remain);\n            }\n\n            var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            stashArray.set(new Uint8Array(chunk, consumed), 0);\n            this._stashUsed += remain;\n            this._stashByteStart = byteStart + consumed;\n          }\n        } else {\n          // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n          if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n            this._expandBuffer(this._stashUsed + chunk.byteLength);\n          }\n\n          var _stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n          _stashArray.set(new Uint8Array(chunk), this._stashUsed);\n\n          this._stashUsed += chunk.byteLength;\n\n          var _consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n\n          if (_consumed < this._stashUsed && _consumed > 0) {\n            // unconsumed data remain\n            var remainArray = new Uint8Array(this._stashBuffer, _consumed);\n\n            _stashArray.set(remainArray, 0);\n          }\n\n          this._stashUsed -= _consumed;\n          this._stashByteStart += _consumed;\n        }\n      } else {\n        // enable stash\n        if (this._stashUsed === 0 && this._stashByteStart === 0) {\n          // seeked? or init chunk?\n          // This is the first chunk after seek action\n          this._stashByteStart = byteStart;\n        }\n\n        if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n          // just stash\n          var _stashArray2 = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n\n          _stashArray2.set(new Uint8Array(chunk), this._stashUsed);\n\n          this._stashUsed += chunk.byteLength;\n        } else {\n          // stashUsed + chunkSize > stashSize, size limit exceeded\n          var _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n          if (this._stashUsed > 0) {\n            // There're stash datas in buffer\n            // dispatch the whole stashBuffer, and stash remain data\n            // then append chunk to stashBuffer (stash)\n            var buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n            var _consumed2 = this._dispatchChunks(buffer, this._stashByteStart);\n\n            if (_consumed2 < buffer.byteLength) {\n              if (_consumed2 > 0) {\n                var _remainArray = new Uint8Array(buffer, _consumed2);\n\n                _stashArray3.set(_remainArray, 0);\n\n                this._stashUsed = _remainArray.byteLength;\n                this._stashByteStart += _consumed2;\n              }\n            } else {\n              this._stashUsed = 0;\n              this._stashByteStart += _consumed2;\n            }\n\n            if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n              this._expandBuffer(this._stashUsed + chunk.byteLength);\n\n              _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            }\n\n            _stashArray3.set(new Uint8Array(chunk), this._stashUsed);\n\n            this._stashUsed += chunk.byteLength;\n          } else {\n            // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n            // dispatch chunk directly and stash remain data\n            var _consumed3 = this._dispatchChunks(chunk, byteStart);\n\n            if (_consumed3 < chunk.byteLength) {\n              var _remain = chunk.byteLength - _consumed3;\n\n              if (_remain > this._bufferSize) {\n                this._expandBuffer(_remain);\n\n                _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n              }\n\n              _stashArray3.set(new Uint8Array(chunk, _consumed3), 0);\n\n              this._stashUsed += _remain;\n              this._stashByteStart = byteStart + _consumed3;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_flushStashBuffer\",\n    value: function _flushStashBuffer(dropUnconsumed) {\n      if (this._stashUsed > 0) {\n        var buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n        var consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n        var remain = buffer.byteLength - consumed;\n\n        if (consumed < buffer.byteLength) {\n          if (dropUnconsumed) {\n            Log.w(this.TAG, \"\".concat(remain, \" bytes unconsumed data remain when flush buffer, dropped\"));\n          } else {\n            if (consumed > 0) {\n              var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n              var remainArray = new Uint8Array(buffer, consumed);\n              stashArray.set(remainArray, 0);\n              this._stashUsed = remainArray.byteLength;\n              this._stashByteStart += consumed;\n            }\n\n            return 0;\n          }\n        }\n\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        return remain;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_onLoaderComplete\",\n    value: function _onLoaderComplete(from, to) {\n      // Force-flush stash buffer, and drop unconsumed data\n      this._flushStashBuffer(true);\n\n      if (this._onComplete) {\n        this._onComplete(this._extraData);\n      }\n    }\n  }, {\n    key: \"_onLoaderError\",\n    value: function _onLoaderError(type, data) {\n      Log.e(this.TAG, \"Loader error, code = \".concat(data.code, \", msg = \").concat(data.msg));\n\n      this._flushStashBuffer(false);\n\n      if (this._isEarlyEofReconnecting) {\n        // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n        this._isEarlyEofReconnecting = false;\n        type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n      }\n\n      switch (type) {\n        case LoaderErrors.EARLY_EOF:\n          {\n            if (!this._config.isLive) {\n              // Do internal http reconnect if not live stream\n              if (this._totalLength) {\n                var nextFrom = this._currentRange.to + 1;\n\n                if (nextFrom < this._totalLength) {\n                  Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                  this._isEarlyEofReconnecting = true;\n\n                  this._internalSeek(nextFrom, false);\n                }\n\n                return;\n              } // else: We don't know totalLength, throw UnrecoverableEarlyEof\n\n            } // live stream: throw UnrecoverableEarlyEof error to upper-layer\n\n\n            type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n            break;\n          }\n\n        case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n        case LoaderErrors.CONNECTING_TIMEOUT:\n        case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n        case LoaderErrors.EXCEPTION:\n          break;\n      }\n\n      if (this._onError) {\n        this._onError(type, data);\n      } else {\n        throw new RuntimeException('IOException: ' + data.msg);\n      }\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this._loader.status;\n    }\n  }, {\n    key: \"extraData\",\n    get: function get() {\n      return this._extraData;\n    },\n    set: function set(data) {\n      this._extraData = data;\n    } // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n\n  }, {\n    key: \"onDataArrival\",\n    get: function get() {\n      return this._onDataArrival;\n    },\n    set: function set(callback) {\n      this._onDataArrival = callback;\n    }\n  }, {\n    key: \"onSeeked\",\n    get: function get() {\n      return this._onSeeked;\n    },\n    set: function set(callback) {\n      this._onSeeked = callback;\n    } // prototype: function onError(type: number, info: {code: number, msg: string}): void\n\n  }, {\n    key: \"onError\",\n    get: function get() {\n      return this._onError;\n    },\n    set: function set(callback) {\n      this._onError = callback;\n    }\n  }, {\n    key: \"onComplete\",\n    get: function get() {\n      return this._onComplete;\n    },\n    set: function set(callback) {\n      this._onComplete = callback;\n    }\n  }, {\n    key: \"onRedirect\",\n    get: function get() {\n      return this._onRedirect;\n    },\n    set: function set(callback) {\n      this._onRedirect = callback;\n    }\n  }, {\n    key: \"onRecoveredEarlyEof\",\n    get: function get() {\n      return this._onRecoveredEarlyEof;\n    },\n    set: function set(callback) {\n      this._onRecoveredEarlyEof = callback;\n    }\n  }, {\n    key: \"currentURL\",\n    get: function get() {\n      return this._dataSource.url;\n    }\n  }, {\n    key: \"hasRedirect\",\n    get: function get() {\n      return this._redirectedURL != null || this._dataSource.redirectedURL != undefined;\n    }\n  }, {\n    key: \"currentRedirectedURL\",\n    get: function get() {\n      return this._redirectedURL || this._dataSource.redirectedURL;\n    } // in KB/s\n\n  }, {\n    key: \"currentSpeed\",\n    get: function get() {\n      if (this._loaderClass === RangeLoader) {\n        // SpeedSampler is inaccuracy if loader is RangeLoader\n        return this._loader.currentSpeed;\n      }\n\n      return this._speedSampler.lastSecondKBps;\n    }\n  }, {\n    key: \"loaderType\",\n    get: function get() {\n      return this._loader.type;\n    }\n  }]);\n\n  return IOController;\n}();\n\nexport default IOController;","map":{"version":3,"sources":["/Users/mitchlew/Documents/Streaming/streams/client/node_modules/flv.js/src/io/io-controller.js"],"names":["Log","SpeedSampler","LoaderStatus","LoaderErrors","FetchStreamLoader","MozChunkedLoader","MSStreamLoader","RangeLoader","WebSocketLoader","RangeSeekHandler","ParamSeekHandler","RuntimeException","IllegalStateException","InvalidArgumentException","IOController","dataSource","config","extraData","TAG","_config","_extraData","_stashInitialSize","stashInitialSize","undefined","_stashUsed","_stashSize","_bufferSize","_stashBuffer","ArrayBuffer","_stashByteStart","_enableStash","enableStashBuffer","_loader","_loaderClass","_seekHandler","_dataSource","_isWebSocketURL","test","url","_refTotalLength","filesize","_totalLength","_fullRequestFlag","_currentRange","_redirectedURL","_speedNormalized","_speedSampler","_speedNormalizeList","_isEarlyEofReconnecting","_paused","_resumeFrom","_onDataArrival","_onSeeked","_onError","_onComplete","_onRedirect","_onRecoveredEarlyEof","_selectSeekHandler","_selectLoader","_createLoader","isWorking","abort","destroy","seekType","rangeLoadZeroStart","paramStart","seekParamStart","paramEnd","seekParamEnd","customSeekHandler","customLoader","isSupported","needStashBuffer","onContentLengthKnown","_onContentLengthKnown","bind","onURLRedirect","_onURLRedirect","onDataArrival","_onLoaderChunkArrival","onComplete","_onLoaderComplete","onError","_onLoaderError","optionalFrom","from","to","reset","open","Object","assign","bytes","_internalSeek","dropUnconsumed","_flushStashBuffer","requestRange","length","expectedBytes","bufferNewSize","newBuffer","stashOldArray","Uint8Array","stashNewArray","set","input","list","last","mid","lbound","ubound","Math","floor","normalized","stashSizeKB","isLive","bufferSize","_expandBuffer","chunks","byteStart","byteLength","redirectedURL","contentLength","chunk","receivedLength","addBytes","KBps","lastSecondKBps","_normalizeSpeed","_adjustStashSize","consumed","_dispatchChunks","remain","stashArray","slice","remainArray","buffer","w","type","data","e","code","msg","UNRECOVERABLE_EARLY_EOF","EARLY_EOF","nextFrom","CONNECTING_TIMEOUT","HTTP_STATUS_CODE_INVALID","EXCEPTION","status","callback","currentSpeed"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport {LoaderStatus, LoaderErrors} from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport {RuntimeException, IllegalStateException, InvalidArgumentException} from '../utils/exception.js';\n\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n\n// Manage IO Loaders\nclass IOController {\n\n    constructor(dataSource, config, extraData) {\n        this.TAG = 'IOController';\n\n        this._config = config;\n        this._extraData = extraData;\n\n        this._stashInitialSize = 1024 * 384;  // default initial size: 384KB\n        if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n            // apply from config\n            this._stashInitialSize = config.stashInitialSize;\n        }\n\n        this._stashUsed = 0;\n        this._stashSize = this._stashInitialSize;\n        this._bufferSize = 1024 * 1024 * 3;  // initial size: 3MB\n        this._stashBuffer = new ArrayBuffer(this._bufferSize);\n        this._stashByteStart = 0;\n        this._enableStash = true;\n        if (config.enableStashBuffer === false) {\n            this._enableStash = false;\n        }\n\n        this._loader = null;\n        this._loaderClass = null;\n        this._seekHandler = null;\n\n        this._dataSource = dataSource;\n        this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n        this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n        this._totalLength = this._refTotalLength;\n        this._fullRequestFlag = false;\n        this._currentRange = null;\n        this._redirectedURL = null;\n\n        this._speedNormalized = 0;\n        this._speedSampler = new SpeedSampler();\n        this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n\n        this._isEarlyEofReconnecting = false;\n\n        this._paused = false;\n        this._resumeFrom = 0;\n\n        this._onDataArrival = null;\n        this._onSeeked = null;\n        this._onError = null;\n        this._onComplete = null;\n        this._onRedirect = null;\n        this._onRecoveredEarlyEof = null;\n\n        this._selectSeekHandler();\n        this._selectLoader();\n        this._createLoader();\n    }\n\n    destroy() {\n        if (this._loader.isWorking()) {\n            this._loader.abort();\n        }\n        this._loader.destroy();\n        this._loader = null;\n        this._loaderClass = null;\n        this._dataSource = null;\n        this._stashBuffer = null;\n        this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n        this._currentRange = null;\n        this._speedSampler = null;\n\n        this._isEarlyEofReconnecting = false;\n\n        this._onDataArrival = null;\n        this._onSeeked = null;\n        this._onError = null;\n        this._onComplete = null;\n        this._onRedirect = null;\n        this._onRecoveredEarlyEof = null;\n\n        this._extraData = null;\n    }\n\n    isWorking() {\n        return this._loader && this._loader.isWorking() && !this._paused;\n    }\n\n    isPaused() {\n        return this._paused;\n    }\n\n    get status() {\n        return this._loader.status;\n    }\n\n    get extraData() {\n        return this._extraData;\n    }\n\n    set extraData(data) {\n        this._extraData = data;\n    }\n\n    // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n    get onDataArrival() {\n        return this._onDataArrival;\n    }\n\n    set onDataArrival(callback) {\n        this._onDataArrival = callback;\n    }\n\n    get onSeeked() {\n        return this._onSeeked;\n    }\n\n    set onSeeked(callback) {\n        this._onSeeked = callback;\n    }\n\n    // prototype: function onError(type: number, info: {code: number, msg: string}): void\n    get onError() {\n        return this._onError;\n    }\n\n    set onError(callback) {\n        this._onError = callback;\n    }\n\n    get onComplete() {\n        return this._onComplete;\n    }\n\n    set onComplete(callback) {\n        this._onComplete = callback;\n    }\n\n    get onRedirect() {\n        return this._onRedirect;\n    }\n\n    set onRedirect(callback) {\n        this._onRedirect = callback;\n    }\n\n    get onRecoveredEarlyEof() {\n        return this._onRecoveredEarlyEof;\n    }\n\n    set onRecoveredEarlyEof(callback) {\n        this._onRecoveredEarlyEof = callback;\n    }\n\n    get currentURL() {\n        return this._dataSource.url;\n    }\n\n    get hasRedirect() {\n        return (this._redirectedURL != null || this._dataSource.redirectedURL != undefined);\n    }\n\n    get currentRedirectedURL() {\n        return this._redirectedURL || this._dataSource.redirectedURL;\n    }\n\n    // in KB/s\n    get currentSpeed() {\n        if (this._loaderClass === RangeLoader) {\n            // SpeedSampler is inaccuracy if loader is RangeLoader\n            return this._loader.currentSpeed;\n        }\n        return this._speedSampler.lastSecondKBps;\n    }\n\n    get loaderType() {\n        return this._loader.type;\n    }\n\n    _selectSeekHandler() {\n        let config = this._config;\n\n        if (config.seekType === 'range') {\n            this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n        } else if (config.seekType === 'param') {\n            let paramStart = config.seekParamStart || 'bstart';\n            let paramEnd = config.seekParamEnd || 'bend';\n\n            this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n        } else if (config.seekType === 'custom') {\n            if (typeof config.customSeekHandler !== 'function') {\n                throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n            }\n            this._seekHandler = new config.customSeekHandler();\n        } else {\n            throw new InvalidArgumentException(`Invalid seekType in config: ${config.seekType}`);\n        }\n    }\n\n    _selectLoader() {\n        if (this._config.customLoader != null) {\n            this._loaderClass = this._config.customLoader;\n        } else if (this._isWebSocketURL) {\n            this._loaderClass = WebSocketLoader;\n        } else if (FetchStreamLoader.isSupported()) {\n            this._loaderClass = FetchStreamLoader;\n        } else if (MozChunkedLoader.isSupported()) {\n            this._loaderClass = MozChunkedLoader;\n        } else if (RangeLoader.isSupported()) {\n            this._loaderClass = RangeLoader;\n        } else {\n            throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n        }\n    }\n\n    _createLoader() {\n        this._loader = new this._loaderClass(this._seekHandler, this._config);\n        if (this._loader.needStashBuffer === false) {\n            this._enableStash = false;\n        }\n        this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n        this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n        this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n        this._loader.onComplete = this._onLoaderComplete.bind(this);\n        this._loader.onError = this._onLoaderError.bind(this);\n    }\n\n    open(optionalFrom) {\n        this._currentRange = {from: 0, to: -1};\n        if (optionalFrom) {\n            this._currentRange.from = optionalFrom;\n        }\n\n        this._speedSampler.reset();\n        if (!optionalFrom) {\n            this._fullRequestFlag = true;\n        }\n\n        this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n    }\n\n    abort() {\n        this._loader.abort();\n\n        if (this._paused) {\n            this._paused = false;\n            this._resumeFrom = 0;\n        }\n    }\n\n    pause() {\n        if (this.isWorking()) {\n            this._loader.abort();\n\n            if (this._stashUsed !== 0) {\n                this._resumeFrom = this._stashByteStart;\n                this._currentRange.to = this._stashByteStart - 1;\n            } else {\n                this._resumeFrom = this._currentRange.to + 1;\n            }\n            this._stashUsed = 0;\n            this._stashByteStart = 0;\n            this._paused = true;\n        }\n    }\n\n    resume() {\n        if (this._paused) {\n            this._paused = false;\n            let bytes = this._resumeFrom;\n            this._resumeFrom = 0;\n            this._internalSeek(bytes, true);\n        }\n    }\n\n    seek(bytes) {\n        this._paused = false;\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        this._internalSeek(bytes, true);\n    }\n\n    /**\n     * When seeking request is from media seeking, unconsumed stash data should be dropped\n     * However, stash data shouldn't be dropped if seeking requested from http reconnection\n     *\n     * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n     */\n    _internalSeek(bytes, dropUnconsumed) {\n        if (this._loader.isWorking()) {\n            this._loader.abort();\n        }\n\n        // dispatch & flush stash buffer before seek\n        this._flushStashBuffer(dropUnconsumed);\n\n        this._loader.destroy();\n        this._loader = null;\n\n        let requestRange = {from: bytes, to: -1};\n        this._currentRange = {from: requestRange.from, to: -1};\n\n        this._speedSampler.reset();\n        this._stashSize = this._stashInitialSize;\n        this._createLoader();\n        this._loader.open(this._dataSource, requestRange);\n\n        if (this._onSeeked) {\n            this._onSeeked();\n        }\n    }\n\n    updateUrl(url) {\n        if (!url || typeof url !== 'string' || url.length === 0) {\n            throw new InvalidArgumentException('Url must be a non-empty string!');\n        }\n\n        this._dataSource.url = url;\n\n        // TODO: replace with new url\n    }\n\n    _expandBuffer(expectedBytes) {\n        let bufferNewSize = this._stashSize;\n        while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n            bufferNewSize *= 2;\n        }\n\n        bufferNewSize += 1024 * 1024 * 1;  // bufferSize = stashSize + 1MB\n        if (bufferNewSize === this._bufferSize) {\n            return;\n        }\n\n        let newBuffer = new ArrayBuffer(bufferNewSize);\n\n        if (this._stashUsed > 0) {  // copy existing data into new buffer\n            let stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n            let stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n            stashNewArray.set(stashOldArray, 0);\n        }\n\n        this._stashBuffer = newBuffer;\n        this._bufferSize = bufferNewSize;\n    }\n\n    _normalizeSpeed(input) {\n        let list = this._speedNormalizeList;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (input < list[0]) {\n            return list[0];\n        }\n\n        // binary search\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (input >= list[mid] && input < list[mid + 1])) {\n                return list[mid];\n            } else if (list[mid] < input) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n    }\n\n    _adjustStashSize(normalized) {\n        let stashSizeKB = 0;\n\n        if (this._config.isLive) {\n            // live stream: always use single normalized speed for size of stashSizeKB\n            stashSizeKB = normalized;\n        } else {\n            if (normalized < 512) {\n                stashSizeKB = normalized;\n            } else if (normalized >= 512 && normalized <= 1024) {\n                stashSizeKB = Math.floor(normalized * 1.5);\n            } else {\n                stashSizeKB = normalized * 2;\n            }\n        }\n\n        if (stashSizeKB > 8192) {\n            stashSizeKB = 8192;\n        }\n\n        let bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1;  // stashSize + 1MB\n        if (this._bufferSize < bufferSize) {\n            this._expandBuffer(bufferSize);\n        }\n        this._stashSize = stashSizeKB * 1024;\n    }\n\n    _dispatchChunks(chunks, byteStart) {\n        this._currentRange.to = byteStart + chunks.byteLength - 1;\n        return this._onDataArrival(chunks, byteStart);\n    }\n\n    _onURLRedirect(redirectedURL) {\n        this._redirectedURL = redirectedURL;\n        if (this._onRedirect) {\n            this._onRedirect(redirectedURL);\n        }\n    }\n\n    _onContentLengthKnown(contentLength) {\n        if (contentLength && this._fullRequestFlag) {\n            this._totalLength = contentLength;\n            this._fullRequestFlag = false;\n        }\n    }\n\n    _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n        if (!this._onDataArrival) {\n            throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n        }\n        if (this._paused) {\n            return;\n        }\n        if (this._isEarlyEofReconnecting) {\n            // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n            this._isEarlyEofReconnecting = false;\n            if (this._onRecoveredEarlyEof) {\n                this._onRecoveredEarlyEof();\n            }\n        }\n\n        this._speedSampler.addBytes(chunk.byteLength);\n\n        // adjust stash buffer size according to network speed dynamically\n        let KBps = this._speedSampler.lastSecondKBps;\n        if (KBps !== 0) {\n            let normalized = this._normalizeSpeed(KBps);\n            if (this._speedNormalized !== normalized) {\n                this._speedNormalized = normalized;\n                this._adjustStashSize(normalized);\n            }\n        }\n\n        if (!this._enableStash) {  // disable stash\n            if (this._stashUsed === 0) {\n                // dispatch chunk directly to consumer;\n                // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n                let consumed = this._dispatchChunks(chunk, byteStart);\n                if (consumed < chunk.byteLength) {  // unconsumed data remain.\n                    let remain = chunk.byteLength - consumed;\n                    if (remain > this._bufferSize) {\n                        this._expandBuffer(remain);\n                    }\n                    let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                    stashArray.set(new Uint8Array(chunk, consumed), 0);\n                    this._stashUsed += remain;\n                    this._stashByteStart = byteStart + consumed;\n                }\n            } else {\n                // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n                if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n                    this._expandBuffer(this._stashUsed + chunk.byteLength);\n                }\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                this._stashUsed += chunk.byteLength;\n                let consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n                if (consumed < this._stashUsed && consumed > 0) {  // unconsumed data remain\n                    let remainArray = new Uint8Array(this._stashBuffer, consumed);\n                    stashArray.set(remainArray, 0);\n                }\n                this._stashUsed -= consumed;\n                this._stashByteStart += consumed;\n            }\n        } else {  // enable stash\n            if (this._stashUsed === 0 && this._stashByteStart === 0) {  // seeked? or init chunk?\n                // This is the first chunk after seek action\n                this._stashByteStart = byteStart;\n            }\n            if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n                // just stash\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n                stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                this._stashUsed += chunk.byteLength;\n            } else {  // stashUsed + chunkSize > stashSize, size limit exceeded\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                if (this._stashUsed > 0) {  // There're stash datas in buffer\n                    // dispatch the whole stashBuffer, and stash remain data\n                    // then append chunk to stashBuffer (stash)\n                    let buffer = this._stashBuffer.slice(0, this._stashUsed);\n                    let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n                    if (consumed < buffer.byteLength) {\n                        if (consumed > 0) {\n                            let remainArray = new Uint8Array(buffer, consumed);\n                            stashArray.set(remainArray, 0);\n                            this._stashUsed = remainArray.byteLength;\n                            this._stashByteStart += consumed;\n                        }\n                    } else {\n                        this._stashUsed = 0;\n                        this._stashByteStart += consumed;\n                    }\n                    if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n                        this._expandBuffer(this._stashUsed + chunk.byteLength);\n                        stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                    }\n                    stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                    this._stashUsed += chunk.byteLength;\n                } else {  // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n                    // dispatch chunk directly and stash remain data\n                    let consumed = this._dispatchChunks(chunk, byteStart);\n                    if (consumed < chunk.byteLength) {\n                        let remain = chunk.byteLength - consumed;\n                        if (remain > this._bufferSize) {\n                            this._expandBuffer(remain);\n                            stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                        }\n                        stashArray.set(new Uint8Array(chunk, consumed), 0);\n                        this._stashUsed += remain;\n                        this._stashByteStart = byteStart + consumed;\n                    }\n                }\n            }\n        }\n    }\n\n    _flushStashBuffer(dropUnconsumed) {\n        if (this._stashUsed > 0) {\n            let buffer = this._stashBuffer.slice(0, this._stashUsed);\n            let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n            let remain = buffer.byteLength - consumed;\n\n            if (consumed < buffer.byteLength) {\n                if (dropUnconsumed) {\n                    Log.w(this.TAG, `${remain} bytes unconsumed data remain when flush buffer, dropped`);\n                } else {\n                    if (consumed > 0) {\n                        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                        let remainArray = new Uint8Array(buffer, consumed);\n                        stashArray.set(remainArray, 0);\n                        this._stashUsed = remainArray.byteLength;\n                        this._stashByteStart += consumed;\n                    }\n                    return 0;\n                }\n            }\n            this._stashUsed = 0;\n            this._stashByteStart = 0;\n            return remain;\n        }\n        return 0;\n    }\n\n    _onLoaderComplete(from, to) {\n        // Force-flush stash buffer, and drop unconsumed data\n        this._flushStashBuffer(true);\n\n        if (this._onComplete) {\n            this._onComplete(this._extraData);\n        }\n    }\n\n    _onLoaderError(type, data) {\n        Log.e(this.TAG, `Loader error, code = ${data.code}, msg = ${data.msg}`);\n\n        this._flushStashBuffer(false);\n\n        if (this._isEarlyEofReconnecting) {\n            // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n            this._isEarlyEofReconnecting = false;\n            type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n        }\n\n        switch (type) {\n            case LoaderErrors.EARLY_EOF: {\n                if (!this._config.isLive) {\n                    // Do internal http reconnect if not live stream\n                    if (this._totalLength) {\n                        let nextFrom = this._currentRange.to + 1;\n                        if (nextFrom < this._totalLength) {\n                            Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                            this._isEarlyEofReconnecting = true;\n                            this._internalSeek(nextFrom, false);\n                        }\n                        return;\n                    }\n                    // else: We don't know totalLength, throw UnrecoverableEarlyEof\n                }\n                // live stream: throw UnrecoverableEarlyEof error to upper-layer\n                type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n                break;\n            }\n            case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n            case LoaderErrors.CONNECTING_TIMEOUT:\n            case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n            case LoaderErrors.EXCEPTION:\n                break;\n        }\n\n        if (this._onError) {\n            this._onError(type, data);\n        } else {\n            throw new RuntimeException('IOException: ' + data.msg);\n        }\n    }\n\n}\n\nexport default IOController;"]},"metadata":{},"sourceType":"module"}