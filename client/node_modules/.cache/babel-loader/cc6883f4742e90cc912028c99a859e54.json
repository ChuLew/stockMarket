{"ast":null,"code":"import _classCallCheck from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mitchlew/Documents/Streaming/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport AMF from './amf-parser.js';\nimport SPSParser from './sps-parser.js';\nimport DemuxErrors from './demux-errors.js';\nimport MediaInfo from '../core/media-info.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nfunction Swap16(src) {\n  return src >>> 8 & 0xFF | (src & 0xFF) << 8;\n}\n\nfunction Swap32(src) {\n  return (src & 0xFF000000) >>> 24 | (src & 0x00FF0000) >>> 8 | (src & 0x0000FF00) << 8 | (src & 0x000000FF) << 24;\n}\n\nfunction ReadBig32(array, index) {\n  return array[index] << 24 | array[index + 1] << 16 | array[index + 2] << 8 | array[index + 3];\n}\n\nvar FLVDemuxer = /*#__PURE__*/function () {\n  function FLVDemuxer(probeData, config) {\n    _classCallCheck(this, FLVDemuxer);\n\n    this.TAG = 'FLVDemuxer';\n    this._config = config;\n    this._onError = null;\n    this._onMediaInfo = null;\n    this._onMetaDataArrived = null;\n    this._onScriptDataArrived = null;\n    this._onTrackMetadata = null;\n    this._onDataAvailable = null;\n    this._dataOffset = probeData.dataOffset;\n    this._firstParse = true;\n    this._dispatch = false;\n    this._hasAudio = probeData.hasAudioTrack;\n    this._hasVideo = probeData.hasVideoTrack;\n    this._hasAudioFlagOverrided = false;\n    this._hasVideoFlagOverrided = false;\n    this._audioInitialMetadataDispatched = false;\n    this._videoInitialMetadataDispatched = false;\n    this._mediaInfo = new MediaInfo();\n    this._mediaInfo.hasAudio = this._hasAudio;\n    this._mediaInfo.hasVideo = this._hasVideo;\n    this._metadata = null;\n    this._audioMetadata = null;\n    this._videoMetadata = null;\n    this._naluLengthSize = 4;\n    this._timestampBase = 0; // int32, in milliseconds\n\n    this._timescale = 1000;\n    this._duration = 0; // int32, in milliseconds\n\n    this._durationOverrided = false;\n    this._referenceFrameRate = {\n      fixed: true,\n      fps: 23.976,\n      fps_num: 23976,\n      fps_den: 1000\n    };\n    this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n    this._mpegSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n    this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n    this._mpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];\n    this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n    this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n    this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];\n    this._videoTrack = {\n      type: 'video',\n      id: 1,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n    this._audioTrack = {\n      type: 'audio',\n      id: 2,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n\n    this._littleEndian = function () {\n      var buf = new ArrayBuffer(2);\n      new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n      return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n    }();\n  }\n\n  _createClass(FLVDemuxer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._mediaInfo = null;\n      this._metadata = null;\n      this._audioMetadata = null;\n      this._videoMetadata = null;\n      this._videoTrack = null;\n      this._audioTrack = null;\n      this._onError = null;\n      this._onMediaInfo = null;\n      this._onMetaDataArrived = null;\n      this._onScriptDataArrived = null;\n      this._onTrackMetadata = null;\n      this._onDataAvailable = null;\n    }\n  }, {\n    key: \"bindDataSource\",\n    value: function bindDataSource(loader) {\n      loader.onDataArrival = this.parseChunks.bind(this);\n      return this;\n    } // prototype: function(type: string, metadata: any): void\n\n  }, {\n    key: \"resetMediaInfo\",\n    value: function resetMediaInfo() {\n      this._mediaInfo = new MediaInfo();\n    }\n  }, {\n    key: \"_isInitialMetadataDispatched\",\n    value: function _isInitialMetadataDispatched() {\n      if (this._hasAudio && this._hasVideo) {\n        // both audio & video\n        return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n      }\n\n      if (this._hasAudio && !this._hasVideo) {\n        // audio only\n        return this._audioInitialMetadataDispatched;\n      }\n\n      if (!this._hasAudio && this._hasVideo) {\n        // video only\n        return this._videoInitialMetadataDispatched;\n      }\n\n      return false;\n    } // function parseChunks(chunk: ArrayBuffer, byteStart: number): number;\n\n  }, {\n    key: \"parseChunks\",\n    value: function parseChunks(chunk, byteStart) {\n      if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n        throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n      }\n\n      var offset = 0;\n      var le = this._littleEndian;\n\n      if (byteStart === 0) {\n        // buffer with FLV header\n        if (chunk.byteLength > 13) {\n          var probeData = FLVDemuxer.probe(chunk);\n          offset = probeData.dataOffset;\n        } else {\n          return 0;\n        }\n      }\n\n      if (this._firstParse) {\n        // handle PreviousTagSize0 before Tag1\n        this._firstParse = false;\n\n        if (byteStart + offset !== this._dataOffset) {\n          Log.w(this.TAG, 'First time parsing but chunk byteStart invalid!');\n        }\n\n        var v = new DataView(chunk, offset);\n        var prevTagSize0 = v.getUint32(0, !le);\n\n        if (prevTagSize0 !== 0) {\n          Log.w(this.TAG, 'PrevTagSize0 !== 0 !!!');\n        }\n\n        offset += 4;\n      }\n\n      while (offset < chunk.byteLength) {\n        this._dispatch = true;\n\n        var _v = new DataView(chunk, offset);\n\n        if (offset + 11 + 4 > chunk.byteLength) {\n          // data not enough for parsing an flv tag\n          break;\n        }\n\n        var tagType = _v.getUint8(0);\n\n        var dataSize = _v.getUint32(0, !le) & 0x00FFFFFF;\n\n        if (offset + 11 + dataSize + 4 > chunk.byteLength) {\n          // data not enough for parsing actual data body\n          break;\n        }\n\n        if (tagType !== 8 && tagType !== 9 && tagType !== 18) {\n          Log.w(this.TAG, \"Unsupported tag type \".concat(tagType, \", skipped\")); // consume the whole tag (skip it)\n\n          offset += 11 + dataSize + 4;\n          continue;\n        }\n\n        var ts2 = _v.getUint8(4);\n\n        var ts1 = _v.getUint8(5);\n\n        var ts0 = _v.getUint8(6);\n\n        var ts3 = _v.getUint8(7);\n\n        var timestamp = ts0 | ts1 << 8 | ts2 << 16 | ts3 << 24;\n        var streamId = _v.getUint32(7, !le) & 0x00FFFFFF;\n\n        if (streamId !== 0) {\n          Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n        }\n\n        var dataOffset = offset + 11;\n\n        switch (tagType) {\n          case 8:\n            // Audio\n            this._parseAudioData(chunk, dataOffset, dataSize, timestamp);\n\n            break;\n\n          case 9:\n            // Video\n            this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);\n\n            break;\n\n          case 18:\n            // ScriptDataObject\n            this._parseScriptData(chunk, dataOffset, dataSize);\n\n            break;\n        }\n\n        var prevTagSize = _v.getUint32(11 + dataSize, !le);\n\n        if (prevTagSize !== 11 + dataSize) {\n          Log.w(this.TAG, \"Invalid PrevTagSize \".concat(prevTagSize));\n        }\n\n        offset += 11 + dataSize + 4; // tagBody + dataSize + prevTagSize\n      } // dispatch parsed frames to consumer (typically, the remuxer)\n\n\n      if (this._isInitialMetadataDispatched()) {\n        if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n          this._onDataAvailable(this._audioTrack, this._videoTrack);\n        }\n      }\n\n      return offset; // consumed bytes, just equals latest offset index\n    }\n  }, {\n    key: \"_parseScriptData\",\n    value: function _parseScriptData(arrayBuffer, dataOffset, dataSize) {\n      var scriptData = AMF.parseScriptData(arrayBuffer, dataOffset, dataSize);\n\n      if (scriptData.hasOwnProperty('onMetaData')) {\n        if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n          Log.w(this.TAG, 'Invalid onMetaData structure!');\n          return;\n        }\n\n        if (this._metadata) {\n          Log.w(this.TAG, 'Found another onMetaData tag!');\n        }\n\n        this._metadata = scriptData;\n        var onMetaData = this._metadata.onMetaData;\n\n        if (this._onMetaDataArrived) {\n          this._onMetaDataArrived(Object.assign({}, onMetaData));\n        }\n\n        if (typeof onMetaData.hasAudio === 'boolean') {\n          // hasAudio\n          if (this._hasAudioFlagOverrided === false) {\n            this._hasAudio = onMetaData.hasAudio;\n            this._mediaInfo.hasAudio = this._hasAudio;\n          }\n        }\n\n        if (typeof onMetaData.hasVideo === 'boolean') {\n          // hasVideo\n          if (this._hasVideoFlagOverrided === false) {\n            this._hasVideo = onMetaData.hasVideo;\n            this._mediaInfo.hasVideo = this._hasVideo;\n          }\n        }\n\n        if (typeof onMetaData.audiodatarate === 'number') {\n          // audiodatarate\n          this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n        }\n\n        if (typeof onMetaData.videodatarate === 'number') {\n          // videodatarate\n          this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n        }\n\n        if (typeof onMetaData.width === 'number') {\n          // width\n          this._mediaInfo.width = onMetaData.width;\n        }\n\n        if (typeof onMetaData.height === 'number') {\n          // height\n          this._mediaInfo.height = onMetaData.height;\n        }\n\n        if (typeof onMetaData.duration === 'number') {\n          // duration\n          if (!this._durationOverrided) {\n            var duration = Math.floor(onMetaData.duration * this._timescale);\n            this._duration = duration;\n            this._mediaInfo.duration = duration;\n          }\n        } else {\n          this._mediaInfo.duration = 0;\n        }\n\n        if (typeof onMetaData.framerate === 'number') {\n          // framerate\n          var fps_num = Math.floor(onMetaData.framerate * 1000);\n\n          if (fps_num > 0) {\n            var fps = fps_num / 1000;\n            this._referenceFrameRate.fixed = true;\n            this._referenceFrameRate.fps = fps;\n            this._referenceFrameRate.fps_num = fps_num;\n            this._referenceFrameRate.fps_den = 1000;\n            this._mediaInfo.fps = fps;\n          }\n        }\n\n        if (typeof onMetaData.keyframes === 'object') {\n          // keyframes\n          this._mediaInfo.hasKeyframesIndex = true;\n          var keyframes = onMetaData.keyframes;\n          this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n          onMetaData.keyframes = null; // keyframes has been extracted, remove it\n        } else {\n          this._mediaInfo.hasKeyframesIndex = false;\n        }\n\n        this._dispatch = false;\n        this._mediaInfo.metadata = onMetaData;\n        Log.v(this.TAG, 'Parsed onMetaData');\n\n        if (this._mediaInfo.isComplete()) {\n          this._onMediaInfo(this._mediaInfo);\n        }\n      }\n\n      if (Object.keys(scriptData).length > 0) {\n        if (this._onScriptDataArrived) {\n          this._onScriptDataArrived(Object.assign({}, scriptData));\n        }\n      }\n    }\n  }, {\n    key: \"_parseKeyframesIndex\",\n    value: function _parseKeyframesIndex(keyframes) {\n      var times = [];\n      var filepositions = []; // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n\n      for (var i = 1; i < keyframes.times.length; i++) {\n        var time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n        times.push(time);\n        filepositions.push(keyframes.filepositions[i]);\n      }\n\n      return {\n        times: times,\n        filepositions: filepositions\n      };\n    }\n  }, {\n    key: \"_parseAudioData\",\n    value: function _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n      if (dataSize <= 1) {\n        Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n        return;\n      }\n\n      if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n        // If hasAudio: false indicated explicitly in MediaDataSource,\n        // Ignore all the audio packets\n        return;\n      }\n\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var soundSpec = v.getUint8(0);\n      var soundFormat = soundSpec >>> 4;\n\n      if (soundFormat !== 2 && soundFormat !== 10) {\n        // MP3 or AAC\n        this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n\n        return;\n      }\n\n      var soundRate = 0;\n      var soundRateIndex = (soundSpec & 12) >>> 2;\n\n      if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n        soundRate = this._flvSoundRateTable[soundRateIndex];\n      } else {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n\n        return;\n      }\n\n      var soundSize = (soundSpec & 2) >>> 1; // unused\n\n      var soundType = soundSpec & 1;\n      var meta = this._audioMetadata;\n      var track = this._audioTrack;\n\n      if (!meta) {\n        if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n          this._hasAudio = true;\n          this._mediaInfo.hasAudio = true;\n        } // initial metadata\n\n\n        meta = this._audioMetadata = {};\n        meta.type = 'audio';\n        meta.id = track.id;\n        meta.timescale = this._timescale;\n        meta.duration = this._duration;\n        meta.audioSampleRate = soundRate;\n        meta.channelCount = soundType === 0 ? 1 : 2;\n      }\n\n      if (soundFormat === 10) {\n        // AAC\n        var aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n\n        if (aacData == undefined) {\n          return;\n        }\n\n        if (aacData.packetType === 0) {\n          // AAC sequence header (AudioSpecificConfig)\n          if (meta.config) {\n            Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n          }\n\n          var misc = aacData.data;\n          meta.audioSampleRate = misc.samplingRate;\n          meta.channelCount = misc.channelCount;\n          meta.codec = misc.codec;\n          meta.originalCodec = misc.originalCodec;\n          meta.config = misc.config; // The decode result of an aac sample is 1024 PCM samples\n\n          meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n          Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n          if (this._isInitialMetadataDispatched()) {\n            // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n              this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n          } else {\n            this._audioInitialMetadataDispatched = true;\n          } // then notify new metadata\n\n\n          this._dispatch = false;\n\n          this._onTrackMetadata('audio', meta);\n\n          var mi = this._mediaInfo;\n          mi.audioCodec = meta.originalCodec;\n          mi.audioSampleRate = meta.audioSampleRate;\n          mi.audioChannelCount = meta.channelCount;\n\n          if (mi.hasVideo) {\n            if (mi.videoCodec != null) {\n              mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n            }\n          } else {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n          }\n\n          if (mi.isComplete()) {\n            this._onMediaInfo(mi);\n          }\n        } else if (aacData.packetType === 1) {\n          // AAC raw frame data\n          var dts = this._timestampBase + tagTimestamp;\n          var aacSample = {\n            unit: aacData.data,\n            length: aacData.data.byteLength,\n            dts: dts,\n            pts: dts\n          };\n          track.samples.push(aacSample);\n          track.length += aacData.data.length;\n        } else {\n          Log.e(this.TAG, \"Flv: Unsupported AAC data type \".concat(aacData.packetType));\n        }\n      } else if (soundFormat === 2) {\n        // MP3\n        if (!meta.codec) {\n          // We need metadata for mp3 audio track, extract info from frame header\n          var _misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);\n\n          if (_misc == undefined) {\n            return;\n          }\n\n          meta.audioSampleRate = _misc.samplingRate;\n          meta.channelCount = _misc.channelCount;\n          meta.codec = _misc.codec;\n          meta.originalCodec = _misc.originalCodec; // The decode result of an mp3 sample is 1152 PCM samples\n\n          meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n          Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n          this._audioInitialMetadataDispatched = true;\n\n          this._onTrackMetadata('audio', meta);\n\n          var _mi = this._mediaInfo;\n          _mi.audioCodec = meta.codec;\n          _mi.audioSampleRate = meta.audioSampleRate;\n          _mi.audioChannelCount = meta.channelCount;\n          _mi.audioDataRate = _misc.bitRate;\n\n          if (_mi.hasVideo) {\n            if (_mi.videoCodec != null) {\n              _mi.mimeType = 'video/x-flv; codecs=\"' + _mi.videoCodec + ',' + _mi.audioCodec + '\"';\n            }\n          } else {\n            _mi.mimeType = 'video/x-flv; codecs=\"' + _mi.audioCodec + '\"';\n          }\n\n          if (_mi.isComplete()) {\n            this._onMediaInfo(_mi);\n          }\n        } // This packet is always a valid audio packet, extract it\n\n\n        var data = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);\n\n        if (data == undefined) {\n          return;\n        }\n\n        var _dts = this._timestampBase + tagTimestamp;\n\n        var mp3Sample = {\n          unit: data,\n          length: data.byteLength,\n          dts: _dts,\n          pts: _dts\n        };\n        track.samples.push(mp3Sample);\n        track.length += data.length;\n      }\n    }\n  }, {\n    key: \"_parseAACAudioData\",\n    value: function _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize <= 1) {\n        Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n        return;\n      }\n\n      var result = {};\n      var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n      result.packetType = array[0];\n\n      if (array[0] === 0) {\n        result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n      } else {\n        result.data = array.subarray(1);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_parseAACAudioSpecificConfig\",\n    value: function _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n      var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n      var config = null;\n      /* Audio Object Type:\n         0: Null\n         1: AAC Main\n         2: AAC LC\n         3: AAC SSR (Scalable Sample Rate)\n         4: AAC LTP (Long Term Prediction)\n         5: HE-AAC / SBR (Spectral Band Replication)\n         6: AAC Scalable\n      */\n\n      var audioObjectType = 0;\n      var originalAudioObjectType = 0;\n      var audioExtensionObjectType = null;\n      var samplingIndex = 0;\n      var extensionSamplingIndex = null; // 5 bits\n\n      audioObjectType = originalAudioObjectType = array[0] >>> 3; // 4 bits\n\n      samplingIndex = (array[0] & 0x07) << 1 | array[1] >>> 7;\n\n      if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n\n        return;\n      }\n\n      var samplingFrequence = this._mpegSamplingRates[samplingIndex]; // 4 bits\n\n      var channelConfig = (array[1] & 0x78) >>> 3;\n\n      if (channelConfig < 0 || channelConfig >= 8) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n\n        return;\n      }\n\n      if (audioObjectType === 5) {\n        // HE-AAC?\n        // 4 bits\n        extensionSamplingIndex = (array[1] & 0x07) << 1 | array[2] >>> 7; // 5 bits\n\n        audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n      } // workarounds for various browsers\n\n\n      var userAgent = self.navigator.userAgent.toLowerCase();\n\n      if (userAgent.indexOf('firefox') !== -1) {\n        // firefox: use SBR (HE-AAC) if freq less than 24kHz\n        if (samplingIndex >= 6) {\n          audioObjectType = 5;\n          config = new Array(4);\n          extensionSamplingIndex = samplingIndex - 3;\n        } else {\n          // use LC-AAC\n          audioObjectType = 2;\n          config = new Array(2);\n          extensionSamplingIndex = samplingIndex;\n        }\n      } else if (userAgent.indexOf('android') !== -1) {\n        // android: always use LC-AAC\n        audioObjectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      } else {\n        // for other browsers, e.g. chrome...\n        // Always use HE-AAC to make it easier to switch aac codec profile\n        audioObjectType = 5;\n        extensionSamplingIndex = samplingIndex;\n        config = new Array(4);\n\n        if (samplingIndex >= 6) {\n          extensionSamplingIndex = samplingIndex - 3;\n        } else if (channelConfig === 1) {\n          // Mono channel\n          audioObjectType = 2;\n          config = new Array(2);\n          extensionSamplingIndex = samplingIndex;\n        }\n      }\n\n      config[0] = audioObjectType << 3;\n      config[0] |= (samplingIndex & 0x0F) >>> 1;\n      config[1] = (samplingIndex & 0x0F) << 7;\n      config[1] |= (channelConfig & 0x0F) << 3;\n\n      if (audioObjectType === 5) {\n        config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n        config[2] = (extensionSamplingIndex & 0x01) << 7; // extended audio object type: force to 2 (LC-AAC)\n\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n\n      return {\n        config: config,\n        samplingRate: samplingFrequence,\n        channelCount: channelConfig,\n        codec: 'mp4a.40.' + audioObjectType,\n        originalCodec: 'mp4a.40.' + originalAudioObjectType\n      };\n    }\n  }, {\n    key: \"_parseMP3AudioData\",\n    value: function _parseMP3AudioData(arrayBuffer, dataOffset, dataSize, requestHeader) {\n      if (dataSize < 4) {\n        Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n        return;\n      }\n\n      var le = this._littleEndian;\n      var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n      var result = null;\n\n      if (requestHeader) {\n        if (array[0] !== 0xFF) {\n          return;\n        }\n\n        var ver = array[1] >>> 3 & 0x03;\n        var layer = (array[1] & 0x06) >> 1;\n        var bitrate_index = (array[2] & 0xF0) >>> 4;\n        var sampling_freq_index = (array[2] & 0x0C) >>> 2;\n        var channel_mode = array[3] >>> 6 & 0x03;\n        var channel_count = channel_mode !== 3 ? 2 : 1;\n        var sample_rate = 0;\n        var bit_rate = 0;\n        var object_type = 34; // Layer-3, listed in MPEG-4 Audio Object Types\n\n        var codec = 'mp3';\n\n        switch (ver) {\n          case 0:\n            // MPEG 2.5\n            sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n            break;\n\n          case 2:\n            // MPEG 2\n            sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n            break;\n\n          case 3:\n            // MPEG 1\n            sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n            break;\n        }\n\n        switch (layer) {\n          case 1:\n            // Layer 3\n            object_type = 34;\n\n            if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n              bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n            }\n\n            break;\n\n          case 2:\n            // Layer 2\n            object_type = 33;\n\n            if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n              bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n            }\n\n            break;\n\n          case 3:\n            // Layer 1\n            object_type = 32;\n\n            if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n              bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n            }\n\n            break;\n        }\n\n        result = {\n          bitRate: bit_rate,\n          samplingRate: sample_rate,\n          channelCount: channel_count,\n          codec: codec,\n          originalCodec: codec\n        };\n      } else {\n        result = array;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_parseVideoData\",\n    value: function _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n      if (dataSize <= 1) {\n        Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n        return;\n      }\n\n      if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n        // If hasVideo: false indicated explicitly in MediaDataSource,\n        // Ignore all the video packets\n        return;\n      }\n\n      var spec = new Uint8Array(arrayBuffer, dataOffset, dataSize)[0];\n      var frameType = (spec & 240) >>> 4;\n      var codecId = spec & 15;\n\n      if (codecId !== 7) {\n        this._onError(DemuxErrors.CODEC_UNSUPPORTED, \"Flv: Unsupported codec in video frame: \".concat(codecId));\n\n        return;\n      }\n\n      this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n    }\n  }, {\n    key: \"_parseAVCVideoPacket\",\n    value: function _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n      if (dataSize < 4) {\n        Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n        return;\n      }\n\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var packetType = v.getUint8(0);\n      var cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n      var cts = cts_unsigned << 8 >> 8; // convert to 24-bit signed int\n\n      if (packetType === 0) {\n        // AVCDecoderConfigurationRecord\n        this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n      } else if (packetType === 1) {\n        // One or more Nalus\n        this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n      } else if (packetType === 2) {// empty, AVC end of sequence\n      } else {\n        this._onError(DemuxErrors.FORMAT_ERROR, \"Flv: Invalid video packet type \".concat(packetType));\n\n        return;\n      }\n    }\n  }, {\n    key: \"_parseAVCDecoderConfigurationRecord\",\n    value: function _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 7) {\n        Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n        return;\n      }\n\n      var meta = this._videoMetadata;\n      var track = this._videoTrack;\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n      if (!meta) {\n        if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n          this._hasVideo = true;\n          this._mediaInfo.hasVideo = true;\n        }\n\n        meta = this._videoMetadata = {};\n        meta.type = 'video';\n        meta.id = track.id;\n        meta.timescale = this._timescale;\n        meta.duration = this._duration;\n      } else {\n        if (typeof meta.avcc !== 'undefined') {\n          Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n        }\n      }\n\n      var version = v.getUint8(0); // configurationVersion\n\n      var avcProfile = v.getUint8(1); // avcProfileIndication\n\n      var profileCompatibility = v.getUint8(2); // profile_compatibility\n\n      var avcLevel = v.getUint8(3); // AVCLevelIndication\n\n      if (version !== 1 || avcProfile === 0) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n\n        return;\n      }\n\n      this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n\n      if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n        // holy shit!!!\n        this._onError(DemuxErrors.FORMAT_ERROR, \"Flv: Strange NaluLengthSizeMinusOne: \".concat(this._naluLengthSize - 1));\n\n        return;\n      }\n\n      var spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n\n      if (spsCount === 0) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n\n        return;\n      } else if (spsCount > 1) {\n        Log.w(this.TAG, \"Flv: Strange AVCDecoderConfigurationRecord: SPS Count = \".concat(spsCount));\n      }\n\n      var offset = 6;\n\n      for (var i = 0; i < spsCount; i++) {\n        var len = v.getUint16(offset, !le); // sequenceParameterSetLength\n\n        offset += 2;\n\n        if (len === 0) {\n          continue;\n        } // Notice: Nalu without startcode header (00 00 00 01)\n\n\n        var sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n        offset += len;\n        var config = SPSParser.parseSPS(sps);\n\n        if (i !== 0) {\n          // ignore other sps's config\n          continue;\n        }\n\n        meta.codecWidth = config.codec_size.width;\n        meta.codecHeight = config.codec_size.height;\n        meta.presentWidth = config.present_size.width;\n        meta.presentHeight = config.present_size.height;\n        meta.profile = config.profile_string;\n        meta.level = config.level_string;\n        meta.bitDepth = config.bit_depth;\n        meta.chromaFormat = config.chroma_format;\n        meta.sarRatio = config.sar_ratio;\n        meta.frameRate = config.frame_rate;\n\n        if (config.frame_rate.fixed === false || config.frame_rate.fps_num === 0 || config.frame_rate.fps_den === 0) {\n          meta.frameRate = this._referenceFrameRate;\n        }\n\n        var fps_den = meta.frameRate.fps_den;\n        var fps_num = meta.frameRate.fps_num;\n        meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n        var codecArray = sps.subarray(1, 4);\n        var codecString = 'avc1.';\n\n        for (var j = 0; j < 3; j++) {\n          var h = codecArray[j].toString(16);\n\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n\n          codecString += h;\n        }\n\n        meta.codec = codecString;\n        var mi = this._mediaInfo;\n        mi.width = meta.codecWidth;\n        mi.height = meta.codecHeight;\n        mi.fps = meta.frameRate.fps;\n        mi.profile = meta.profile;\n        mi.level = meta.level;\n        mi.refFrames = config.ref_frames;\n        mi.chromaFormat = config.chroma_format_string;\n        mi.sarNum = meta.sarRatio.width;\n        mi.sarDen = meta.sarRatio.height;\n        mi.videoCodec = codecString;\n\n        if (mi.hasAudio) {\n          if (mi.audioCodec != null) {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n          }\n        } else {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n        }\n\n        if (mi.isComplete()) {\n          this._onMediaInfo(mi);\n        }\n      }\n\n      var ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n\n      if (ppsCount === 0) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n\n        return;\n      } else if (ppsCount > 1) {\n        Log.w(this.TAG, \"Flv: Strange AVCDecoderConfigurationRecord: PPS Count = \".concat(ppsCount));\n      }\n\n      offset++;\n\n      for (var _i = 0; _i < ppsCount; _i++) {\n        var _len = v.getUint16(offset, !le); // pictureParameterSetLength\n\n\n        offset += 2;\n\n        if (_len === 0) {\n          continue;\n        } // pps is useless for extracting video information\n\n\n        offset += _len;\n      }\n\n      meta.avcc = new Uint8Array(dataSize);\n      meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n      Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n      if (this._isInitialMetadataDispatched()) {\n        // flush parsed frames\n        if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n          this._onDataAvailable(this._audioTrack, this._videoTrack);\n        }\n      } else {\n        this._videoInitialMetadataDispatched = true;\n      } // notify new metadata\n\n\n      this._dispatch = false;\n\n      this._onTrackMetadata('video', meta);\n    }\n  }, {\n    key: \"_parseAVCVideoData\",\n    value: function _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var units = [],\n          length = 0;\n      var offset = 0;\n      var lengthSize = this._naluLengthSize;\n      var dts = this._timestampBase + tagTimestamp;\n      var keyframe = frameType === 1; // from FLV Frame Type constants\n\n      while (offset < dataSize) {\n        if (offset + 4 >= dataSize) {\n          Log.w(this.TAG, \"Malformed Nalu near timestamp \".concat(dts, \", offset = \").concat(offset, \", dataSize = \").concat(dataSize));\n          break; // data not enough for next Nalu\n        } // Nalu with length-header (AVC1)\n\n\n        var naluSize = v.getUint32(offset, !le); // Big-Endian read\n\n        if (lengthSize === 3) {\n          naluSize >>>= 8;\n        }\n\n        if (naluSize > dataSize - lengthSize) {\n          Log.w(this.TAG, \"Malformed Nalus near timestamp \".concat(dts, \", NaluSize > DataSize!\"));\n          return;\n        }\n\n        var unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n        if (unitType === 5) {\n          // IDR\n          keyframe = true;\n        }\n\n        var data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n        var unit = {\n          type: unitType,\n          data: data\n        };\n        units.push(unit);\n        length += data.byteLength;\n        offset += lengthSize + naluSize;\n      }\n\n      if (units.length) {\n        var track = this._videoTrack;\n        var avcSample = {\n          units: units,\n          length: length,\n          isKeyframe: keyframe,\n          dts: dts,\n          cts: cts,\n          pts: dts + cts\n        };\n\n        if (keyframe) {\n          avcSample.fileposition = tagPosition;\n        }\n\n        track.samples.push(avcSample);\n        track.length += length;\n      }\n    }\n  }, {\n    key: \"onTrackMetadata\",\n    get: function get() {\n      return this._onTrackMetadata;\n    },\n    set: function set(callback) {\n      this._onTrackMetadata = callback;\n    } // prototype: function(mediaInfo: MediaInfo): void\n\n  }, {\n    key: \"onMediaInfo\",\n    get: function get() {\n      return this._onMediaInfo;\n    },\n    set: function set(callback) {\n      this._onMediaInfo = callback;\n    }\n  }, {\n    key: \"onMetaDataArrived\",\n    get: function get() {\n      return this._onMetaDataArrived;\n    },\n    set: function set(callback) {\n      this._onMetaDataArrived = callback;\n    }\n  }, {\n    key: \"onScriptDataArrived\",\n    get: function get() {\n      return this._onScriptDataArrived;\n    },\n    set: function set(callback) {\n      this._onScriptDataArrived = callback;\n    } // prototype: function(type: number, info: string): void\n\n  }, {\n    key: \"onError\",\n    get: function get() {\n      return this._onError;\n    },\n    set: function set(callback) {\n      this._onError = callback;\n    } // prototype: function(videoTrack: any, audioTrack: any): void\n\n  }, {\n    key: \"onDataAvailable\",\n    get: function get() {\n      return this._onDataAvailable;\n    },\n    set: function set(callback) {\n      this._onDataAvailable = callback;\n    } // timestamp base for output samples, must be in milliseconds\n\n  }, {\n    key: \"timestampBase\",\n    get: function get() {\n      return this._timestampBase;\n    },\n    set: function set(base) {\n      this._timestampBase = base;\n    }\n  }, {\n    key: \"overridedDuration\",\n    get: function get() {\n      return this._duration;\n    } // Force-override media duration. Must be in milliseconds, int32\n    ,\n    set: function set(duration) {\n      this._durationOverrided = true;\n      this._duration = duration;\n      this._mediaInfo.duration = duration;\n    } // Force-override audio track present flag, boolean\n\n  }, {\n    key: \"overridedHasAudio\",\n    set: function set(hasAudio) {\n      this._hasAudioFlagOverrided = true;\n      this._hasAudio = hasAudio;\n      this._mediaInfo.hasAudio = hasAudio;\n    } // Force-override video track present flag, boolean\n\n  }, {\n    key: \"overridedHasVideo\",\n    set: function set(hasVideo) {\n      this._hasVideoFlagOverrided = true;\n      this._hasVideo = hasVideo;\n      this._mediaInfo.hasVideo = hasVideo;\n    }\n  }], [{\n    key: \"probe\",\n    value: function probe(buffer) {\n      var data = new Uint8Array(buffer);\n      var mismatch = {\n        match: false\n      };\n\n      if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n        return mismatch;\n      }\n\n      var hasAudio = (data[4] & 4) >>> 2 !== 0;\n      var hasVideo = (data[4] & 1) !== 0;\n      var offset = ReadBig32(data, 5);\n\n      if (offset < 9) {\n        return mismatch;\n      }\n\n      return {\n        match: true,\n        consumed: offset,\n        dataOffset: offset,\n        hasAudioTrack: hasAudio,\n        hasVideoTrack: hasVideo\n      };\n    }\n  }]);\n\n  return FLVDemuxer;\n}();\n\nexport default FLVDemuxer;","map":{"version":3,"sources":["/Users/mitchlew/Documents/Streaming/streams/client/node_modules/flv.js/src/demux/flv-demuxer.js"],"names":["Log","AMF","SPSParser","DemuxErrors","MediaInfo","IllegalStateException","Swap16","src","Swap32","ReadBig32","array","index","FLVDemuxer","probeData","config","TAG","_config","_onError","_onMediaInfo","_onMetaDataArrived","_onScriptDataArrived","_onTrackMetadata","_onDataAvailable","_dataOffset","dataOffset","_firstParse","_dispatch","_hasAudio","hasAudioTrack","_hasVideo","hasVideoTrack","_hasAudioFlagOverrided","_hasVideoFlagOverrided","_audioInitialMetadataDispatched","_videoInitialMetadataDispatched","_mediaInfo","hasAudio","hasVideo","_metadata","_audioMetadata","_videoMetadata","_naluLengthSize","_timestampBase","_timescale","_duration","_durationOverrided","_referenceFrameRate","fixed","fps","fps_num","fps_den","_flvSoundRateTable","_mpegSamplingRates","_mpegAudioV10SampleRateTable","_mpegAudioV20SampleRateTable","_mpegAudioV25SampleRateTable","_mpegAudioL1BitRateTable","_mpegAudioL2BitRateTable","_mpegAudioL3BitRateTable","_videoTrack","type","id","sequenceNumber","samples","length","_audioTrack","_littleEndian","buf","ArrayBuffer","DataView","setInt16","Int16Array","loader","onDataArrival","parseChunks","bind","chunk","byteStart","offset","le","byteLength","probe","w","v","prevTagSize0","getUint32","tagType","getUint8","dataSize","ts2","ts1","ts0","ts3","timestamp","streamId","_parseAudioData","_parseVideoData","_parseScriptData","prevTagSize","_isInitialMetadataDispatched","arrayBuffer","scriptData","parseScriptData","hasOwnProperty","onMetaData","Object","assign","audiodatarate","audioDataRate","videodatarate","videoDataRate","width","height","duration","Math","floor","framerate","keyframes","hasKeyframesIndex","keyframesIndex","_parseKeyframesIndex","metadata","isComplete","keys","times","filepositions","i","time","push","tagTimestamp","soundSpec","soundFormat","CODEC_UNSUPPORTED","soundRate","soundRateIndex","FORMAT_ERROR","soundSize","soundType","meta","track","timescale","audioSampleRate","channelCount","aacData","_parseAACAudioData","undefined","packetType","misc","data","samplingRate","codec","originalCodec","refSampleDuration","mi","audioCodec","audioChannelCount","videoCodec","mimeType","dts","aacSample","unit","pts","e","_parseMP3AudioData","bitRate","mp3Sample","result","Uint8Array","_parseAACAudioSpecificConfig","subarray","audioObjectType","originalAudioObjectType","audioExtensionObjectType","samplingIndex","extensionSamplingIndex","samplingFrequence","channelConfig","userAgent","self","navigator","toLowerCase","indexOf","Array","requestHeader","ver","layer","bitrate_index","sampling_freq_index","channel_mode","channel_count","sample_rate","bit_rate","object_type","tagPosition","spec","frameType","codecId","_parseAVCVideoPacket","cts_unsigned","cts","_parseAVCDecoderConfigurationRecord","_parseAVCVideoData","avcc","version","avcProfile","profileCompatibility","avcLevel","spsCount","len","getUint16","sps","parseSPS","codecWidth","codec_size","codecHeight","presentWidth","present_size","presentHeight","profile","profile_string","level","level_string","bitDepth","bit_depth","chromaFormat","chroma_format","sarRatio","sar_ratio","frameRate","frame_rate","codecArray","codecString","j","h","toString","refFrames","ref_frames","chroma_format_string","sarNum","sarDen","ppsCount","set","units","lengthSize","keyframe","naluSize","unitType","avcSample","isKeyframe","fileposition","callback","base","buffer","mismatch","match","consumed"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;AAkBA,OAAOA,GAAP,MAAgB,oBAAhB;AACA,OAAOC,GAAP,MAAgB,iBAAhB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,OAAOC,WAAP,MAAwB,mBAAxB;AACA,OAAOC,SAAP,MAAsB,uBAAtB;AACA,SAAQC,qBAAR,QAAoC,uBAApC;;AAEA,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;AACjB,SAAUA,GAAG,KAAK,CAAT,GAAc,IAAf,GACC,CAACA,GAAG,GAAG,IAAP,KAAgB,CADzB;AAEH;;AAED,SAASC,MAAT,CAAgBD,GAAhB,EAAqB;AACjB,SAAS,CAACA,GAAG,GAAG,UAAP,MAAuB,EAAxB,GACC,CAACA,GAAG,GAAG,UAAP,MAAuB,CADxB,GAEC,CAACA,GAAG,GAAG,UAAP,KAAsB,CAFvB,GAGC,CAACA,GAAG,GAAG,UAAP,KAAsB,EAH/B;AAIH;;AAED,SAASE,SAAT,CAAmBC,KAAnB,EAA0BC,KAA1B,EAAiC;AAC7B,SAASD,KAAK,CAACC,KAAD,CAAL,IAAgB,EAAjB,GACCD,KAAK,CAACC,KAAK,GAAG,CAAT,CAAL,IAAoB,EADrB,GAECD,KAAK,CAACC,KAAK,GAAG,CAAT,CAAL,IAAoB,CAFrB,GAGCD,KAAK,CAACC,KAAK,GAAG,CAAT,CAHd;AAIH;;IAGKC,U;AAEF,sBAAYC,SAAZ,EAAuBC,MAAvB,EAA+B;AAAA;;AAC3B,SAAKC,GAAL,GAAW,YAAX;AAEA,SAAKC,OAAL,GAAeF,MAAf;AAEA,SAAKG,QAAL,GAAgB,IAAhB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,kBAAL,GAA0B,IAA1B;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AAEA,SAAKC,WAAL,GAAmBV,SAAS,CAACW,UAA7B;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AAEA,SAAKC,SAAL,GAAiBd,SAAS,CAACe,aAA3B;AACA,SAAKC,SAAL,GAAiBhB,SAAS,CAACiB,aAA3B;AAEA,SAAKC,sBAAL,GAA8B,KAA9B;AACA,SAAKC,sBAAL,GAA8B,KAA9B;AAEA,SAAKC,+BAAL,GAAuC,KAAvC;AACA,SAAKC,+BAAL,GAAuC,KAAvC;AAEA,SAAKC,UAAL,GAAkB,IAAI/B,SAAJ,EAAlB;AACA,SAAK+B,UAAL,CAAgBC,QAAhB,GAA2B,KAAKT,SAAhC;AACA,SAAKQ,UAAL,CAAgBE,QAAhB,GAA2B,KAAKR,SAAhC;AACA,SAAKS,SAAL,GAAiB,IAAjB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AAEA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,cAAL,GAAsB,CAAtB,CAjC2B,CAiCD;;AAC1B,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,SAAL,GAAiB,CAAjB,CAnC2B,CAmCN;;AACrB,SAAKC,kBAAL,GAA0B,KAA1B;AACA,SAAKC,mBAAL,GAA2B;AACvBC,MAAAA,KAAK,EAAE,IADgB;AAEvBC,MAAAA,GAAG,EAAE,MAFkB;AAGvBC,MAAAA,OAAO,EAAE,KAHc;AAIvBC,MAAAA,OAAO,EAAE;AAJc,KAA3B;AAOA,SAAKC,kBAAL,GAA0B,CAAC,IAAD,EAAO,KAAP,EAAc,KAAd,EAAqB,KAArB,EAA4B,KAA5B,CAA1B;AAEA,SAAKC,kBAAL,GAA0B,CACtB,KADsB,EACf,KADe,EACR,KADQ,EACD,KADC,EACM,KADN,EACa,KADb,EAEtB,KAFsB,EAEf,KAFe,EAER,KAFQ,EAED,KAFC,EAEM,KAFN,EAEa,IAFb,EAEmB,IAFnB,CAA1B;AAKA,SAAKC,4BAAL,GAAoC,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,CAAtB,CAApC;AACA,SAAKC,4BAAL,GAAoC,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,CAAtB,CAApC;AACA,SAAKC,4BAAL,GAAoC,CAAC,KAAD,EAAQ,KAAR,EAAe,IAAf,EAAsB,CAAtB,CAApC;AAEA,SAAKC,wBAAL,GAAgC,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,EAAY,EAAZ,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,GAAlE,EAAuE,CAAC,CAAxE,CAAhC;AACA,SAAKC,wBAAL,GAAgC,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,EAAY,EAAZ,EAAiB,EAAjB,EAAsB,EAAtB,EAA2B,EAA3B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,GAAlE,EAAuE,CAAC,CAAxE,CAAhC;AACA,SAAKC,wBAAL,GAAgC,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,EAAY,EAAZ,EAAiB,EAAjB,EAAsB,EAAtB,EAA2B,EAA3B,EAAgC,EAAhC,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,GAAlE,EAAuE,CAAC,CAAxE,CAAhC;AAEA,SAAKC,WAAL,GAAmB;AAACC,MAAAA,IAAI,EAAE,OAAP;AAAgBC,MAAAA,EAAE,EAAE,CAApB;AAAuBC,MAAAA,cAAc,EAAE,CAAvC;AAA0CC,MAAAA,OAAO,EAAE,EAAnD;AAAuDC,MAAAA,MAAM,EAAE;AAA/D,KAAnB;AACA,SAAKC,WAAL,GAAmB;AAACL,MAAAA,IAAI,EAAE,OAAP;AAAgBC,MAAAA,EAAE,EAAE,CAApB;AAAuBC,MAAAA,cAAc,EAAE,CAAvC;AAA0CC,MAAAA,OAAO,EAAE,EAAnD;AAAuDC,MAAAA,MAAM,EAAE;AAA/D,KAAnB;;AAEA,SAAKE,aAAL,GAAsB,YAAY;AAC9B,UAAIC,GAAG,GAAG,IAAIC,WAAJ,CAAgB,CAAhB,CAAV;AACC,UAAIC,QAAJ,CAAaF,GAAb,CAAD,CAAoBG,QAApB,CAA6B,CAA7B,EAAgC,GAAhC,EAAqC,IAArC,EAF8B,CAEe;;AAC7C,aAAQ,IAAIC,UAAJ,CAAeJ,GAAf,CAAD,CAAsB,CAAtB,MAA6B,GAApC,CAH8B,CAGY;AAC7C,KAJoB,EAArB;AAKH;;;;8BAES;AACN,WAAKhC,UAAL,GAAkB,IAAlB;AACA,WAAKG,SAAL,GAAiB,IAAjB;AACA,WAAKC,cAAL,GAAsB,IAAtB;AACA,WAAKC,cAAL,GAAsB,IAAtB;AACA,WAAKmB,WAAL,GAAmB,IAAnB;AACA,WAAKM,WAAL,GAAmB,IAAnB;AAEA,WAAKhD,QAAL,GAAgB,IAAhB;AACA,WAAKC,YAAL,GAAoB,IAApB;AACA,WAAKC,kBAAL,GAA0B,IAA1B;AACA,WAAKC,oBAAL,GAA4B,IAA5B;AACA,WAAKC,gBAAL,GAAwB,IAAxB;AACA,WAAKC,gBAAL,GAAwB,IAAxB;AACH;;;mCA4BckD,M,EAAQ;AACnBA,MAAAA,MAAM,CAACC,aAAP,GAAuB,KAAKC,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAvB;AACA,aAAO,IAAP;AACH,K,CAED;;;;qCAsFiB;AACb,WAAKxC,UAAL,GAAkB,IAAI/B,SAAJ,EAAlB;AACH;;;mDAE8B;AAC3B,UAAI,KAAKuB,SAAL,IAAkB,KAAKE,SAA3B,EAAsC;AAAG;AACrC,eAAO,KAAKI,+BAAL,IAAwC,KAAKC,+BAApD;AACH;;AACD,UAAI,KAAKP,SAAL,IAAkB,CAAC,KAAKE,SAA5B,EAAuC;AAAG;AACtC,eAAO,KAAKI,+BAAZ;AACH;;AACD,UAAI,CAAC,KAAKN,SAAN,IAAmB,KAAKE,SAA5B,EAAuC;AAAG;AACtC,eAAO,KAAKK,+BAAZ;AACH;;AACD,aAAO,KAAP;AACH,K,CAED;;;;gCACY0C,K,EAAOC,S,EAAW;AAC1B,UAAI,CAAC,KAAK5D,QAAN,IAAkB,CAAC,KAAKC,YAAxB,IAAwC,CAAC,KAAKG,gBAA9C,IAAkE,CAAC,KAAKC,gBAA5E,EAA8F;AAC1F,cAAM,IAAIjB,qBAAJ,CAA0B,2FAA1B,CAAN;AACH;;AAED,UAAIyE,MAAM,GAAG,CAAb;AACA,UAAIC,EAAE,GAAG,KAAKb,aAAd;;AAEA,UAAIW,SAAS,KAAK,CAAlB,EAAqB;AAAG;AACpB,YAAID,KAAK,CAACI,UAAN,GAAmB,EAAvB,EAA2B;AACvB,cAAInE,SAAS,GAAGD,UAAU,CAACqE,KAAX,CAAiBL,KAAjB,CAAhB;AACAE,UAAAA,MAAM,GAAGjE,SAAS,CAACW,UAAnB;AACH,SAHD,MAGO;AACH,iBAAO,CAAP;AACH;AACJ;;AAED,UAAI,KAAKC,WAAT,EAAsB;AAAG;AACrB,aAAKA,WAAL,GAAmB,KAAnB;;AACA,YAAIoD,SAAS,GAAGC,MAAZ,KAAuB,KAAKvD,WAAhC,EAA6C;AACzCvB,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,iDAAhB;AACH;;AAED,YAAIoE,CAAC,GAAG,IAAId,QAAJ,CAAaO,KAAb,EAAoBE,MAApB,CAAR;AACA,YAAIM,YAAY,GAAGD,CAAC,CAACE,SAAF,CAAY,CAAZ,EAAe,CAACN,EAAhB,CAAnB;;AACA,YAAIK,YAAY,KAAK,CAArB,EAAwB;AACpBpF,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,wBAAhB;AACH;;AACD+D,QAAAA,MAAM,IAAI,CAAV;AACH;;AAED,aAAOA,MAAM,GAAGF,KAAK,CAACI,UAAtB,EAAkC;AAC9B,aAAKtD,SAAL,GAAiB,IAAjB;;AAEA,YAAIyD,EAAC,GAAG,IAAId,QAAJ,CAAaO,KAAb,EAAoBE,MAApB,CAAR;;AAEA,YAAIA,MAAM,GAAG,EAAT,GAAc,CAAd,GAAkBF,KAAK,CAACI,UAA5B,EAAwC;AACpC;AACA;AACH;;AAED,YAAIM,OAAO,GAAGH,EAAC,CAACI,QAAF,CAAW,CAAX,CAAd;;AACA,YAAIC,QAAQ,GAAGL,EAAC,CAACE,SAAF,CAAY,CAAZ,EAAe,CAACN,EAAhB,IAAsB,UAArC;;AAEA,YAAID,MAAM,GAAG,EAAT,GAAcU,QAAd,GAAyB,CAAzB,GAA6BZ,KAAK,CAACI,UAAvC,EAAmD;AAC/C;AACA;AACH;;AAED,YAAIM,OAAO,KAAK,CAAZ,IAAiBA,OAAO,KAAK,CAA7B,IAAkCA,OAAO,KAAK,EAAlD,EAAsD;AAClDtF,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,iCAAwCuE,OAAxC,gBADkD,CAElD;;AACAR,UAAAA,MAAM,IAAI,KAAKU,QAAL,GAAgB,CAA1B;AACA;AACH;;AAED,YAAIC,GAAG,GAAGN,EAAC,CAACI,QAAF,CAAW,CAAX,CAAV;;AACA,YAAIG,GAAG,GAAGP,EAAC,CAACI,QAAF,CAAW,CAAX,CAAV;;AACA,YAAII,GAAG,GAAGR,EAAC,CAACI,QAAF,CAAW,CAAX,CAAV;;AACA,YAAIK,GAAG,GAAGT,EAAC,CAACI,QAAF,CAAW,CAAX,CAAV;;AAEA,YAAIM,SAAS,GAAGF,GAAG,GAAID,GAAG,IAAI,CAAd,GAAoBD,GAAG,IAAI,EAA3B,GAAkCG,GAAG,IAAI,EAAzD;AAEA,YAAIE,QAAQ,GAAGX,EAAC,CAACE,SAAF,CAAY,CAAZ,EAAe,CAACN,EAAhB,IAAsB,UAArC;;AACA,YAAIe,QAAQ,KAAK,CAAjB,EAAoB;AAChB9F,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,mCAAhB;AACH;;AAED,YAAIS,UAAU,GAAGsD,MAAM,GAAG,EAA1B;;AAEA,gBAAQQ,OAAR;AACI,eAAK,CAAL;AAAS;AACL,iBAAKS,eAAL,CAAqBnB,KAArB,EAA4BpD,UAA5B,EAAwCgE,QAAxC,EAAkDK,SAAlD;;AACA;;AACJ,eAAK,CAAL;AAAS;AACL,iBAAKG,eAAL,CAAqBpB,KAArB,EAA4BpD,UAA5B,EAAwCgE,QAAxC,EAAkDK,SAAlD,EAA6DhB,SAAS,GAAGC,MAAzE;;AACA;;AACJ,eAAK,EAAL;AAAU;AACN,iBAAKmB,gBAAL,CAAsBrB,KAAtB,EAA6BpD,UAA7B,EAAyCgE,QAAzC;;AACA;AATR;;AAYA,YAAIU,WAAW,GAAGf,EAAC,CAACE,SAAF,CAAY,KAAKG,QAAjB,EAA2B,CAACT,EAA5B,CAAlB;;AACA,YAAImB,WAAW,KAAK,KAAKV,QAAzB,EAAmC;AAC/BxF,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,gCAAuCmF,WAAvC;AACH;;AAEDpB,QAAAA,MAAM,IAAI,KAAKU,QAAL,GAAgB,CAA1B,CAxD8B,CAwDA;AACjC,OAxFyB,CA0F1B;;;AACA,UAAI,KAAKW,4BAAL,EAAJ,EAAyC;AACrC,YAAI,KAAKzE,SAAL,KAAmB,KAAKuC,WAAL,CAAiBD,MAAjB,IAA2B,KAAKL,WAAL,CAAiBK,MAA/D,CAAJ,EAA4E;AACxE,eAAK1C,gBAAL,CAAsB,KAAK2C,WAA3B,EAAwC,KAAKN,WAA7C;AACH;AACJ;;AAED,aAAOmB,MAAP,CAjG0B,CAiGV;AACnB;;;qCAEgBsB,W,EAAa5E,U,EAAYgE,Q,EAAU;AAChD,UAAIa,UAAU,GAAGpG,GAAG,CAACqG,eAAJ,CAAoBF,WAApB,EAAiC5E,UAAjC,EAA6CgE,QAA7C,CAAjB;;AAEA,UAAIa,UAAU,CAACE,cAAX,CAA0B,YAA1B,CAAJ,EAA6C;AACzC,YAAIF,UAAU,CAACG,UAAX,IAAyB,IAAzB,IAAiC,OAAOH,UAAU,CAACG,UAAlB,KAAiC,QAAtE,EAAgF;AAC5ExG,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,+BAAhB;AACA;AACH;;AACD,YAAI,KAAKuB,SAAT,EAAoB;AAChBtC,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,+BAAhB;AACH;;AACD,aAAKuB,SAAL,GAAiB+D,UAAjB;AACA,YAAIG,UAAU,GAAG,KAAKlE,SAAL,CAAekE,UAAhC;;AAEA,YAAI,KAAKrF,kBAAT,EAA6B;AACzB,eAAKA,kBAAL,CAAwBsF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,UAAlB,CAAxB;AACH;;AAED,YAAI,OAAOA,UAAU,CAACpE,QAAlB,KAA+B,SAAnC,EAA8C;AAAG;AAC7C,cAAI,KAAKL,sBAAL,KAAgC,KAApC,EAA2C;AACvC,iBAAKJ,SAAL,GAAiB6E,UAAU,CAACpE,QAA5B;AACA,iBAAKD,UAAL,CAAgBC,QAAhB,GAA2B,KAAKT,SAAhC;AACH;AACJ;;AACD,YAAI,OAAO6E,UAAU,CAACnE,QAAlB,KAA+B,SAAnC,EAA8C;AAAG;AAC7C,cAAI,KAAKL,sBAAL,KAAgC,KAApC,EAA2C;AACvC,iBAAKH,SAAL,GAAiB2E,UAAU,CAACnE,QAA5B;AACA,iBAAKF,UAAL,CAAgBE,QAAhB,GAA2B,KAAKR,SAAhC;AACH;AACJ;;AACD,YAAI,OAAO2E,UAAU,CAACG,aAAlB,KAAoC,QAAxC,EAAkD;AAAG;AACjD,eAAKxE,UAAL,CAAgByE,aAAhB,GAAgCJ,UAAU,CAACG,aAA3C;AACH;;AACD,YAAI,OAAOH,UAAU,CAACK,aAAlB,KAAoC,QAAxC,EAAkD;AAAG;AACjD,eAAK1E,UAAL,CAAgB2E,aAAhB,GAAgCN,UAAU,CAACK,aAA3C;AACH;;AACD,YAAI,OAAOL,UAAU,CAACO,KAAlB,KAA4B,QAAhC,EAA0C;AAAG;AACzC,eAAK5E,UAAL,CAAgB4E,KAAhB,GAAwBP,UAAU,CAACO,KAAnC;AACH;;AACD,YAAI,OAAOP,UAAU,CAACQ,MAAlB,KAA6B,QAAjC,EAA2C;AAAG;AAC1C,eAAK7E,UAAL,CAAgB6E,MAAhB,GAAyBR,UAAU,CAACQ,MAApC;AACH;;AACD,YAAI,OAAOR,UAAU,CAACS,QAAlB,KAA+B,QAAnC,EAA6C;AAAG;AAC5C,cAAI,CAAC,KAAKpE,kBAAV,EAA8B;AAC1B,gBAAIoE,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWX,UAAU,CAACS,QAAX,GAAsB,KAAKtE,UAAtC,CAAf;AACA,iBAAKC,SAAL,GAAiBqE,QAAjB;AACA,iBAAK9E,UAAL,CAAgB8E,QAAhB,GAA2BA,QAA3B;AACH;AACJ,SAND,MAMO;AACH,eAAK9E,UAAL,CAAgB8E,QAAhB,GAA2B,CAA3B;AACH;;AACD,YAAI,OAAOT,UAAU,CAACY,SAAlB,KAAgC,QAApC,EAA8C;AAAG;AAC7C,cAAInE,OAAO,GAAGiE,IAAI,CAACC,KAAL,CAAWX,UAAU,CAACY,SAAX,GAAuB,IAAlC,CAAd;;AACA,cAAInE,OAAO,GAAG,CAAd,EAAiB;AACb,gBAAID,GAAG,GAAGC,OAAO,GAAG,IAApB;AACA,iBAAKH,mBAAL,CAAyBC,KAAzB,GAAiC,IAAjC;AACA,iBAAKD,mBAAL,CAAyBE,GAAzB,GAA+BA,GAA/B;AACA,iBAAKF,mBAAL,CAAyBG,OAAzB,GAAmCA,OAAnC;AACA,iBAAKH,mBAAL,CAAyBI,OAAzB,GAAmC,IAAnC;AACA,iBAAKf,UAAL,CAAgBa,GAAhB,GAAsBA,GAAtB;AACH;AACJ;;AACD,YAAI,OAAOwD,UAAU,CAACa,SAAlB,KAAgC,QAApC,EAA8C;AAAG;AAC7C,eAAKlF,UAAL,CAAgBmF,iBAAhB,GAAoC,IAApC;AACA,cAAID,SAAS,GAAGb,UAAU,CAACa,SAA3B;AACA,eAAKlF,UAAL,CAAgBoF,cAAhB,GAAiC,KAAKC,oBAAL,CAA0BH,SAA1B,CAAjC;AACAb,UAAAA,UAAU,CAACa,SAAX,GAAuB,IAAvB,CAJ0C,CAIZ;AACjC,SALD,MAKO;AACH,eAAKlF,UAAL,CAAgBmF,iBAAhB,GAAoC,KAApC;AACH;;AACD,aAAK5F,SAAL,GAAiB,KAAjB;AACA,aAAKS,UAAL,CAAgBsF,QAAhB,GAA2BjB,UAA3B;AACAxG,QAAAA,GAAG,CAACmF,CAAJ,CAAM,KAAKpE,GAAX,EAAgB,mBAAhB;;AACA,YAAI,KAAKoB,UAAL,CAAgBuF,UAAhB,EAAJ,EAAkC;AAC9B,eAAKxG,YAAL,CAAkB,KAAKiB,UAAvB;AACH;AACJ;;AAED,UAAIsE,MAAM,CAACkB,IAAP,CAAYtB,UAAZ,EAAwBrC,MAAxB,GAAiC,CAArC,EAAwC;AACpC,YAAI,KAAK5C,oBAAT,EAA+B;AAC3B,eAAKA,oBAAL,CAA0BqF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,UAAlB,CAA1B;AACH;AACJ;AACJ;;;yCAEoBgB,S,EAAW;AAC5B,UAAIO,KAAK,GAAG,EAAZ;AACA,UAAIC,aAAa,GAAG,EAApB,CAF4B,CAI5B;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAAS,CAACO,KAAV,CAAgB5D,MAApC,EAA4C8D,CAAC,EAA7C,EAAiD;AAC7C,YAAIC,IAAI,GAAG,KAAKrF,cAAL,GAAsBwE,IAAI,CAACC,KAAL,CAAWE,SAAS,CAACO,KAAV,CAAgBE,CAAhB,IAAqB,IAAhC,CAAjC;AACAF,QAAAA,KAAK,CAACI,IAAN,CAAWD,IAAX;AACAF,QAAAA,aAAa,CAACG,IAAd,CAAmBX,SAAS,CAACQ,aAAV,CAAwBC,CAAxB,CAAnB;AACH;;AAED,aAAO;AACHF,QAAAA,KAAK,EAAEA,KADJ;AAEHC,QAAAA,aAAa,EAAEA;AAFZ,OAAP;AAIH;;;oCAEezB,W,EAAa5E,U,EAAYgE,Q,EAAUyC,Y,EAAc;AAC7D,UAAIzC,QAAQ,IAAI,CAAhB,EAAmB;AACfxF,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,uDAAhB;AACA;AACH;;AAED,UAAI,KAAKgB,sBAAL,KAAgC,IAAhC,IAAwC,KAAKJ,SAAL,KAAmB,KAA/D,EAAsE;AAClE;AACA;AACA;AACH;;AAED,UAAIoD,EAAE,GAAG,KAAKb,aAAd;AACA,UAAIiB,CAAC,GAAG,IAAId,QAAJ,CAAa+B,WAAb,EAA0B5E,UAA1B,EAAsCgE,QAAtC,CAAR;AAEA,UAAI0C,SAAS,GAAG/C,CAAC,CAACI,QAAF,CAAW,CAAX,CAAhB;AAEA,UAAI4C,WAAW,GAAGD,SAAS,KAAK,CAAhC;;AACA,UAAIC,WAAW,KAAK,CAAhB,IAAqBA,WAAW,KAAK,EAAzC,EAA6C;AAAG;AAC5C,aAAKlH,QAAL,CAAcd,WAAW,CAACiI,iBAA1B,EAA6C,uCAAuCD,WAApF;;AACA;AACH;;AAED,UAAIE,SAAS,GAAG,CAAhB;AACA,UAAIC,cAAc,GAAG,CAACJ,SAAS,GAAG,EAAb,MAAqB,CAA1C;;AACA,UAAII,cAAc,IAAI,CAAlB,IAAuBA,cAAc,IAAI,CAA7C,EAAgD;AAC5CD,QAAAA,SAAS,GAAG,KAAKlF,kBAAL,CAAwBmF,cAAxB,CAAZ;AACH,OAFD,MAEO;AACH,aAAKrH,QAAL,CAAcd,WAAW,CAACoI,YAA1B,EAAwC,yCAAyCD,cAAjF;;AACA;AACH;;AAED,UAAIE,SAAS,GAAG,CAACN,SAAS,GAAG,CAAb,MAAoB,CAApC,CAhC6D,CAgCrB;;AACxC,UAAIO,SAAS,GAAIP,SAAS,GAAG,CAA7B;AAGA,UAAIQ,IAAI,GAAG,KAAKnG,cAAhB;AACA,UAAIoG,KAAK,GAAG,KAAK1E,WAAjB;;AAEA,UAAI,CAACyE,IAAL,EAAW;AACP,YAAI,KAAK/G,SAAL,KAAmB,KAAnB,IAA4B,KAAKI,sBAAL,KAAgC,KAAhE,EAAuE;AACnE,eAAKJ,SAAL,GAAiB,IAAjB;AACA,eAAKQ,UAAL,CAAgBC,QAAhB,GAA2B,IAA3B;AACH,SAJM,CAMP;;;AACAsG,QAAAA,IAAI,GAAG,KAAKnG,cAAL,GAAsB,EAA7B;AACAmG,QAAAA,IAAI,CAAC9E,IAAL,GAAY,OAAZ;AACA8E,QAAAA,IAAI,CAAC7E,EAAL,GAAU8E,KAAK,CAAC9E,EAAhB;AACA6E,QAAAA,IAAI,CAACE,SAAL,GAAiB,KAAKjG,UAAtB;AACA+F,QAAAA,IAAI,CAACzB,QAAL,GAAgB,KAAKrE,SAArB;AACA8F,QAAAA,IAAI,CAACG,eAAL,GAAuBR,SAAvB;AACAK,QAAAA,IAAI,CAACI,YAAL,GAAqBL,SAAS,KAAK,CAAd,GAAkB,CAAlB,GAAsB,CAA3C;AACH;;AAED,UAAIN,WAAW,KAAK,EAApB,EAAwB;AAAG;AACvB,YAAIY,OAAO,GAAG,KAAKC,kBAAL,CAAwB5C,WAAxB,EAAqC5E,UAAU,GAAG,CAAlD,EAAqDgE,QAAQ,GAAG,CAAhE,CAAd;;AACA,YAAIuD,OAAO,IAAIE,SAAf,EAA0B;AACtB;AACH;;AAED,YAAIF,OAAO,CAACG,UAAR,KAAuB,CAA3B,EAA8B;AAAG;AAC7B,cAAIR,IAAI,CAAC5H,MAAT,EAAiB;AACbd,YAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,oCAAhB;AACH;;AACD,cAAIoI,IAAI,GAAGJ,OAAO,CAACK,IAAnB;AACAV,UAAAA,IAAI,CAACG,eAAL,GAAuBM,IAAI,CAACE,YAA5B;AACAX,UAAAA,IAAI,CAACI,YAAL,GAAoBK,IAAI,CAACL,YAAzB;AACAJ,UAAAA,IAAI,CAACY,KAAL,GAAaH,IAAI,CAACG,KAAlB;AACAZ,UAAAA,IAAI,CAACa,aAAL,GAAqBJ,IAAI,CAACI,aAA1B;AACAb,UAAAA,IAAI,CAAC5H,MAAL,GAAcqI,IAAI,CAACrI,MAAnB,CAT0B,CAU1B;;AACA4H,UAAAA,IAAI,CAACc,iBAAL,GAAyB,OAAOd,IAAI,CAACG,eAAZ,GAA8BH,IAAI,CAACE,SAA5D;AACA5I,UAAAA,GAAG,CAACmF,CAAJ,CAAM,KAAKpE,GAAX,EAAgB,4BAAhB;;AAEA,cAAI,KAAKoF,4BAAL,EAAJ,EAAyC;AACrC;AACA,gBAAI,KAAKzE,SAAL,KAAmB,KAAKuC,WAAL,CAAiBD,MAAjB,IAA2B,KAAKL,WAAL,CAAiBK,MAA/D,CAAJ,EAA4E;AACxE,mBAAK1C,gBAAL,CAAsB,KAAK2C,WAA3B,EAAwC,KAAKN,WAA7C;AACH;AACJ,WALD,MAKO;AACH,iBAAK1B,+BAAL,GAAuC,IAAvC;AACH,WArByB,CAsB1B;;;AACA,eAAKP,SAAL,GAAiB,KAAjB;;AACA,eAAKL,gBAAL,CAAsB,OAAtB,EAA+BqH,IAA/B;;AAEA,cAAIe,EAAE,GAAG,KAAKtH,UAAd;AACAsH,UAAAA,EAAE,CAACC,UAAH,GAAgBhB,IAAI,CAACa,aAArB;AACAE,UAAAA,EAAE,CAACZ,eAAH,GAAqBH,IAAI,CAACG,eAA1B;AACAY,UAAAA,EAAE,CAACE,iBAAH,GAAuBjB,IAAI,CAACI,YAA5B;;AACA,cAAIW,EAAE,CAACpH,QAAP,EAAiB;AACb,gBAAIoH,EAAE,CAACG,UAAH,IAAiB,IAArB,EAA2B;AACvBH,cAAAA,EAAE,CAACI,QAAH,GAAc,0BAA0BJ,EAAE,CAACG,UAA7B,GAA0C,GAA1C,GAAgDH,EAAE,CAACC,UAAnD,GAAgE,GAA9E;AACH;AACJ,WAJD,MAIO;AACHD,YAAAA,EAAE,CAACI,QAAH,GAAc,0BAA0BJ,EAAE,CAACC,UAA7B,GAA0C,GAAxD;AACH;;AACD,cAAID,EAAE,CAAC/B,UAAH,EAAJ,EAAqB;AACjB,iBAAKxG,YAAL,CAAkBuI,EAAlB;AACH;AACJ,SAxCD,MAwCO,IAAIV,OAAO,CAACG,UAAR,KAAuB,CAA3B,EAA8B;AAAG;AACpC,cAAIY,GAAG,GAAG,KAAKpH,cAAL,GAAsBuF,YAAhC;AACA,cAAI8B,SAAS,GAAG;AAACC,YAAAA,IAAI,EAAEjB,OAAO,CAACK,IAAf;AAAqBpF,YAAAA,MAAM,EAAE+E,OAAO,CAACK,IAAR,CAAapE,UAA1C;AAAsD8E,YAAAA,GAAG,EAAEA,GAA3D;AAAgEG,YAAAA,GAAG,EAAEH;AAArE,WAAhB;AACAnB,UAAAA,KAAK,CAAC5E,OAAN,CAAciE,IAAd,CAAmB+B,SAAnB;AACApB,UAAAA,KAAK,CAAC3E,MAAN,IAAgB+E,OAAO,CAACK,IAAR,CAAapF,MAA7B;AACH,SALM,MAKA;AACHhE,UAAAA,GAAG,CAACkK,CAAJ,CAAM,KAAKnJ,GAAX,2CAAkDgI,OAAO,CAACG,UAA1D;AACH;AACJ,OAtDD,MAsDO,IAAIf,WAAW,KAAK,CAApB,EAAuB;AAAG;AAC7B,YAAI,CAACO,IAAI,CAACY,KAAV,EAAiB;AACb;AACA,cAAIH,KAAI,GAAG,KAAKgB,kBAAL,CAAwB/D,WAAxB,EAAqC5E,UAAU,GAAG,CAAlD,EAAqDgE,QAAQ,GAAG,CAAhE,EAAmE,IAAnE,CAAX;;AACA,cAAI2D,KAAI,IAAIF,SAAZ,EAAuB;AACnB;AACH;;AACDP,UAAAA,IAAI,CAACG,eAAL,GAAuBM,KAAI,CAACE,YAA5B;AACAX,UAAAA,IAAI,CAACI,YAAL,GAAoBK,KAAI,CAACL,YAAzB;AACAJ,UAAAA,IAAI,CAACY,KAAL,GAAaH,KAAI,CAACG,KAAlB;AACAZ,UAAAA,IAAI,CAACa,aAAL,GAAqBJ,KAAI,CAACI,aAA1B,CATa,CAUb;;AACAb,UAAAA,IAAI,CAACc,iBAAL,GAAyB,OAAOd,IAAI,CAACG,eAAZ,GAA8BH,IAAI,CAACE,SAA5D;AACA5I,UAAAA,GAAG,CAACmF,CAAJ,CAAM,KAAKpE,GAAX,EAAgB,gCAAhB;AAEA,eAAKkB,+BAAL,GAAuC,IAAvC;;AACA,eAAKZ,gBAAL,CAAsB,OAAtB,EAA+BqH,IAA/B;;AAEA,cAAIe,GAAE,GAAG,KAAKtH,UAAd;AACAsH,UAAAA,GAAE,CAACC,UAAH,GAAgBhB,IAAI,CAACY,KAArB;AACAG,UAAAA,GAAE,CAACZ,eAAH,GAAqBH,IAAI,CAACG,eAA1B;AACAY,UAAAA,GAAE,CAACE,iBAAH,GAAuBjB,IAAI,CAACI,YAA5B;AACAW,UAAAA,GAAE,CAAC7C,aAAH,GAAmBuC,KAAI,CAACiB,OAAxB;;AACA,cAAIX,GAAE,CAACpH,QAAP,EAAiB;AACb,gBAAIoH,GAAE,CAACG,UAAH,IAAiB,IAArB,EAA2B;AACvBH,cAAAA,GAAE,CAACI,QAAH,GAAc,0BAA0BJ,GAAE,CAACG,UAA7B,GAA0C,GAA1C,GAAgDH,GAAE,CAACC,UAAnD,GAAgE,GAA9E;AACH;AACJ,WAJD,MAIO;AACHD,YAAAA,GAAE,CAACI,QAAH,GAAc,0BAA0BJ,GAAE,CAACC,UAA7B,GAA0C,GAAxD;AACH;;AACD,cAAID,GAAE,CAAC/B,UAAH,EAAJ,EAAqB;AACjB,iBAAKxG,YAAL,CAAkBuI,GAAlB;AACH;AACJ,SAjCyB,CAmC1B;;;AACA,YAAIL,IAAI,GAAG,KAAKe,kBAAL,CAAwB/D,WAAxB,EAAqC5E,UAAU,GAAG,CAAlD,EAAqDgE,QAAQ,GAAG,CAAhE,EAAmE,KAAnE,CAAX;;AACA,YAAI4D,IAAI,IAAIH,SAAZ,EAAuB;AACnB;AACH;;AACD,YAAIa,IAAG,GAAG,KAAKpH,cAAL,GAAsBuF,YAAhC;;AACA,YAAIoC,SAAS,GAAG;AAACL,UAAAA,IAAI,EAAEZ,IAAP;AAAapF,UAAAA,MAAM,EAAEoF,IAAI,CAACpE,UAA1B;AAAsC8E,UAAAA,GAAG,EAAEA,IAA3C;AAAgDG,UAAAA,GAAG,EAAEH;AAArD,SAAhB;AACAnB,QAAAA,KAAK,CAAC5E,OAAN,CAAciE,IAAd,CAAmBqC,SAAnB;AACA1B,QAAAA,KAAK,CAAC3E,MAAN,IAAgBoF,IAAI,CAACpF,MAArB;AACH;AACJ;;;uCAEkBoC,W,EAAa5E,U,EAAYgE,Q,EAAU;AAClD,UAAIA,QAAQ,IAAI,CAAhB,EAAmB;AACfxF,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,6DAAhB;AACA;AACH;;AAED,UAAIuJ,MAAM,GAAG,EAAb;AACA,UAAI5J,KAAK,GAAG,IAAI6J,UAAJ,CAAenE,WAAf,EAA4B5E,UAA5B,EAAwCgE,QAAxC,CAAZ;AAEA8E,MAAAA,MAAM,CAACpB,UAAP,GAAoBxI,KAAK,CAAC,CAAD,CAAzB;;AAEA,UAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAjB,EAAoB;AAChB4J,QAAAA,MAAM,CAAClB,IAAP,GAAc,KAAKoB,4BAAL,CAAkCpE,WAAlC,EAA+C5E,UAAU,GAAG,CAA5D,EAA+DgE,QAAQ,GAAG,CAA1E,CAAd;AACH,OAFD,MAEO;AACH8E,QAAAA,MAAM,CAAClB,IAAP,GAAc1I,KAAK,CAAC+J,QAAN,CAAe,CAAf,CAAd;AACH;;AAED,aAAOH,MAAP;AACH;;;iDAE4BlE,W,EAAa5E,U,EAAYgE,Q,EAAU;AAC5D,UAAI9E,KAAK,GAAG,IAAI6J,UAAJ,CAAenE,WAAf,EAA4B5E,UAA5B,EAAwCgE,QAAxC,CAAZ;AACA,UAAI1E,MAAM,GAAG,IAAb;AAEA;;;;;;;;;;AAUA,UAAI4J,eAAe,GAAG,CAAtB;AACA,UAAIC,uBAAuB,GAAG,CAA9B;AACA,UAAIC,wBAAwB,GAAG,IAA/B;AACA,UAAIC,aAAa,GAAG,CAApB;AACA,UAAIC,sBAAsB,GAAG,IAA7B,CAlB4D,CAoB5D;;AACAJ,MAAAA,eAAe,GAAGC,uBAAuB,GAAGjK,KAAK,CAAC,CAAD,CAAL,KAAa,CAAzD,CArB4D,CAsB5D;;AACAmK,MAAAA,aAAa,GAAI,CAACnK,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,CAAtB,GAA4BA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAzD;;AACA,UAAImK,aAAa,GAAG,CAAhB,IAAqBA,aAAa,IAAI,KAAKzH,kBAAL,CAAwBY,MAAlE,EAA0E;AACtE,aAAK/C,QAAL,CAAcd,WAAW,CAACoI,YAA1B,EAAwC,4CAAxC;;AACA;AACH;;AAED,UAAIwC,iBAAiB,GAAG,KAAK3H,kBAAL,CAAwByH,aAAxB,CAAxB,CA7B4D,CA+B5D;;AACA,UAAIG,aAAa,GAAG,CAACtK,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,MAAsB,CAA1C;;AACA,UAAIsK,aAAa,GAAG,CAAhB,IAAqBA,aAAa,IAAI,CAA1C,EAA6C;AACzC,aAAK/J,QAAL,CAAcd,WAAW,CAACoI,YAA1B,EAAwC,wCAAxC;;AACA;AACH;;AAED,UAAImC,eAAe,KAAK,CAAxB,EAA2B;AAAG;AAC1B;AACAI,QAAAA,sBAAsB,GAAI,CAACpK,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,CAAtB,GAA4BA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAlE,CAFuB,CAGvB;;AACAkK,QAAAA,wBAAwB,GAAG,CAAClK,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,MAAsB,CAAjD;AACH,OA3C2D,CA6C5D;;;AACA,UAAIuK,SAAS,GAAGC,IAAI,CAACC,SAAL,CAAeF,SAAf,CAAyBG,WAAzB,EAAhB;;AAEA,UAAIH,SAAS,CAACI,OAAV,CAAkB,SAAlB,MAAiC,CAAC,CAAtC,EAAyC;AACrC;AACA,YAAIR,aAAa,IAAI,CAArB,EAAwB;AACpBH,UAAAA,eAAe,GAAG,CAAlB;AACA5J,UAAAA,MAAM,GAAG,IAAIwK,KAAJ,CAAU,CAAV,CAAT;AACAR,UAAAA,sBAAsB,GAAGD,aAAa,GAAG,CAAzC;AACH,SAJD,MAIO;AAAG;AACNH,UAAAA,eAAe,GAAG,CAAlB;AACA5J,UAAAA,MAAM,GAAG,IAAIwK,KAAJ,CAAU,CAAV,CAAT;AACAR,UAAAA,sBAAsB,GAAGD,aAAzB;AACH;AACJ,OAXD,MAWO,IAAII,SAAS,CAACI,OAAV,CAAkB,SAAlB,MAAiC,CAAC,CAAtC,EAAyC;AAC5C;AACAX,QAAAA,eAAe,GAAG,CAAlB;AACA5J,QAAAA,MAAM,GAAG,IAAIwK,KAAJ,CAAU,CAAV,CAAT;AACAR,QAAAA,sBAAsB,GAAGD,aAAzB;AACH,OALM,MAKA;AACH;AACA;AACAH,QAAAA,eAAe,GAAG,CAAlB;AACAI,QAAAA,sBAAsB,GAAGD,aAAzB;AACA/J,QAAAA,MAAM,GAAG,IAAIwK,KAAJ,CAAU,CAAV,CAAT;;AAEA,YAAIT,aAAa,IAAI,CAArB,EAAwB;AACpBC,UAAAA,sBAAsB,GAAGD,aAAa,GAAG,CAAzC;AACH,SAFD,MAEO,IAAIG,aAAa,KAAK,CAAtB,EAAyB;AAAG;AAC/BN,UAAAA,eAAe,GAAG,CAAlB;AACA5J,UAAAA,MAAM,GAAG,IAAIwK,KAAJ,CAAU,CAAV,CAAT;AACAR,UAAAA,sBAAsB,GAAGD,aAAzB;AACH;AACJ;;AAED/J,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAa4J,eAAe,IAAI,CAAhC;AACA5J,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAa,CAAC+J,aAAa,GAAG,IAAjB,MAA2B,CAAxC;AACA/J,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAa,CAAC+J,aAAa,GAAG,IAAjB,KAA0B,CAAvC;AACA/J,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAa,CAACkK,aAAa,GAAG,IAAjB,KAA0B,CAAvC;;AACA,UAAIN,eAAe,KAAK,CAAxB,EAA2B;AACvB5J,QAAAA,MAAM,CAAC,CAAD,CAAN,IAAc,CAACgK,sBAAsB,GAAG,IAA1B,MAAoC,CAAlD;AACAhK,QAAAA,MAAM,CAAC,CAAD,CAAN,GAAa,CAACgK,sBAAsB,GAAG,IAA1B,KAAmC,CAAhD,CAFuB,CAGvB;;AACAhK,QAAAA,MAAM,CAAC,CAAD,CAAN,IAAc,KAAK,CAAnB;AACAA,QAAAA,MAAM,CAAC,CAAD,CAAN,GAAa,CAAb;AACH;;AAED,aAAO;AACHA,QAAAA,MAAM,EAAEA,MADL;AAEHuI,QAAAA,YAAY,EAAE0B,iBAFX;AAGHjC,QAAAA,YAAY,EAAEkC,aAHX;AAIH1B,QAAAA,KAAK,EAAE,aAAaoB,eAJjB;AAKHnB,QAAAA,aAAa,EAAE,aAAaoB;AALzB,OAAP;AAOH;;;uCAEkBvE,W,EAAa5E,U,EAAYgE,Q,EAAU+F,a,EAAe;AACjE,UAAI/F,QAAQ,GAAG,CAAf,EAAkB;AACdxF,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,0CAAhB;AACA;AACH;;AAED,UAAIgE,EAAE,GAAG,KAAKb,aAAd;AACA,UAAIxD,KAAK,GAAG,IAAI6J,UAAJ,CAAenE,WAAf,EAA4B5E,UAA5B,EAAwCgE,QAAxC,CAAZ;AACA,UAAI8E,MAAM,GAAG,IAAb;;AAEA,UAAIiB,aAAJ,EAAmB;AACf,YAAI7K,KAAK,CAAC,CAAD,CAAL,KAAa,IAAjB,EAAuB;AACnB;AACH;;AACD,YAAI8K,GAAG,GAAI9K,KAAK,CAAC,CAAD,CAAL,KAAa,CAAd,GAAmB,IAA7B;AACA,YAAI+K,KAAK,GAAG,CAAC/K,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,KAAqB,CAAjC;AAEA,YAAIgL,aAAa,GAAG,CAAChL,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,MAAsB,CAA1C;AACA,YAAIiL,mBAAmB,GAAG,CAACjL,KAAK,CAAC,CAAD,CAAL,GAAW,IAAZ,MAAsB,CAAhD;AAEA,YAAIkL,YAAY,GAAIlL,KAAK,CAAC,CAAD,CAAL,KAAa,CAAd,GAAmB,IAAtC;AACA,YAAImL,aAAa,GAAGD,YAAY,KAAK,CAAjB,GAAqB,CAArB,GAAyB,CAA7C;AAEA,YAAIE,WAAW,GAAG,CAAlB;AACA,YAAIC,QAAQ,GAAG,CAAf;AACA,YAAIC,WAAW,GAAG,EAAlB,CAfe,CAeQ;;AAEvB,YAAI1C,KAAK,GAAG,KAAZ;;AAEA,gBAAQkC,GAAR;AACI,eAAK,CAAL;AAAS;AACLM,YAAAA,WAAW,GAAG,KAAKvI,4BAAL,CAAkCoI,mBAAlC,CAAd;AACA;;AACJ,eAAK,CAAL;AAAS;AACLG,YAAAA,WAAW,GAAG,KAAKxI,4BAAL,CAAkCqI,mBAAlC,CAAd;AACA;;AACJ,eAAK,CAAL;AAAS;AACLG,YAAAA,WAAW,GAAG,KAAKzI,4BAAL,CAAkCsI,mBAAlC,CAAd;AACA;AATR;;AAYA,gBAAQF,KAAR;AACI,eAAK,CAAL;AAAS;AACLO,YAAAA,WAAW,GAAG,EAAd;;AACA,gBAAIN,aAAa,GAAG,KAAKhI,wBAAL,CAA8BM,MAAlD,EAA0D;AACtD+H,cAAAA,QAAQ,GAAG,KAAKrI,wBAAL,CAA8BgI,aAA9B,CAAX;AACH;;AACD;;AACJ,eAAK,CAAL;AAAS;AACLM,YAAAA,WAAW,GAAG,EAAd;;AACA,gBAAIN,aAAa,GAAG,KAAKjI,wBAAL,CAA8BO,MAAlD,EAA0D;AACtD+H,cAAAA,QAAQ,GAAG,KAAKtI,wBAAL,CAA8BiI,aAA9B,CAAX;AACH;;AACD;;AACJ,eAAK,CAAL;AAAS;AACLM,YAAAA,WAAW,GAAG,EAAd;;AACA,gBAAIN,aAAa,GAAG,KAAKlI,wBAAL,CAA8BQ,MAAlD,EAA0D;AACtD+H,cAAAA,QAAQ,GAAG,KAAKvI,wBAAL,CAA8BkI,aAA9B,CAAX;AACH;;AACD;AAlBR;;AAqBApB,QAAAA,MAAM,GAAG;AACLF,UAAAA,OAAO,EAAE2B,QADJ;AAEL1C,UAAAA,YAAY,EAAEyC,WAFT;AAGLhD,UAAAA,YAAY,EAAE+C,aAHT;AAILvC,UAAAA,KAAK,EAAEA,KAJF;AAKLC,UAAAA,aAAa,EAAED;AALV,SAAT;AAOH,OA3DD,MA2DO;AACHgB,QAAAA,MAAM,GAAG5J,KAAT;AACH;;AAED,aAAO4J,MAAP;AACH;;;oCAEelE,W,EAAa5E,U,EAAYgE,Q,EAAUyC,Y,EAAcgE,W,EAAa;AAC1E,UAAIzG,QAAQ,IAAI,CAAhB,EAAmB;AACfxF,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,uDAAhB;AACA;AACH;;AAED,UAAI,KAAKiB,sBAAL,KAAgC,IAAhC,IAAwC,KAAKH,SAAL,KAAmB,KAA/D,EAAsE;AAClE;AACA;AACA;AACH;;AAED,UAAIqK,IAAI,GAAI,IAAI3B,UAAJ,CAAenE,WAAf,EAA4B5E,UAA5B,EAAwCgE,QAAxC,CAAD,CAAoD,CAApD,CAAX;AAEA,UAAI2G,SAAS,GAAG,CAACD,IAAI,GAAG,GAAR,MAAiB,CAAjC;AACA,UAAIE,OAAO,GAAGF,IAAI,GAAG,EAArB;;AAEA,UAAIE,OAAO,KAAK,CAAhB,EAAmB;AACf,aAAKnL,QAAL,CAAcd,WAAW,CAACiI,iBAA1B,mDAAuFgE,OAAvF;;AACA;AACH;;AAED,WAAKC,oBAAL,CAA0BjG,WAA1B,EAAuC5E,UAAU,GAAG,CAApD,EAAuDgE,QAAQ,GAAG,CAAlE,EAAqEyC,YAArE,EAAmFgE,WAAnF,EAAgGE,SAAhG;AACH;;;yCAEoB/F,W,EAAa5E,U,EAAYgE,Q,EAAUyC,Y,EAAcgE,W,EAAaE,S,EAAW;AAC1F,UAAI3G,QAAQ,GAAG,CAAf,EAAkB;AACdxF,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,uEAAhB;AACA;AACH;;AAED,UAAIgE,EAAE,GAAG,KAAKb,aAAd;AACA,UAAIiB,CAAC,GAAG,IAAId,QAAJ,CAAa+B,WAAb,EAA0B5E,UAA1B,EAAsCgE,QAAtC,CAAR;AAEA,UAAI0D,UAAU,GAAG/D,CAAC,CAACI,QAAF,CAAW,CAAX,CAAjB;AACA,UAAI+G,YAAY,GAAGnH,CAAC,CAACE,SAAF,CAAY,CAAZ,EAAe,CAACN,EAAhB,IAAsB,UAAzC;AACA,UAAIwH,GAAG,GAAID,YAAY,IAAI,CAAjB,IAAuB,CAAjC,CAX0F,CAWrD;;AAErC,UAAIpD,UAAU,KAAK,CAAnB,EAAsB;AAAG;AACrB,aAAKsD,mCAAL,CAAyCpG,WAAzC,EAAsD5E,UAAU,GAAG,CAAnE,EAAsEgE,QAAQ,GAAG,CAAjF;AACH,OAFD,MAEO,IAAI0D,UAAU,KAAK,CAAnB,EAAsB;AAAG;AAC5B,aAAKuD,kBAAL,CAAwBrG,WAAxB,EAAqC5E,UAAU,GAAG,CAAlD,EAAqDgE,QAAQ,GAAG,CAAhE,EAAmEyC,YAAnE,EAAiFgE,WAAjF,EAA8FE,SAA9F,EAAyGI,GAAzG;AACH,OAFM,MAEA,IAAIrD,UAAU,KAAK,CAAnB,EAAsB,CACzB;AACH,OAFM,MAEA;AACH,aAAKjI,QAAL,CAAcd,WAAW,CAACoI,YAA1B,2CAA0EW,UAA1E;;AACA;AACH;AACJ;;;wDAEmC9C,W,EAAa5E,U,EAAYgE,Q,EAAU;AACnE,UAAIA,QAAQ,GAAG,CAAf,EAAkB;AACdxF,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,2DAAhB;AACA;AACH;;AAED,UAAI2H,IAAI,GAAG,KAAKlG,cAAhB;AACA,UAAImG,KAAK,GAAG,KAAKhF,WAAjB;AACA,UAAIoB,EAAE,GAAG,KAAKb,aAAd;AACA,UAAIiB,CAAC,GAAG,IAAId,QAAJ,CAAa+B,WAAb,EAA0B5E,UAA1B,EAAsCgE,QAAtC,CAAR;;AAEA,UAAI,CAACkD,IAAL,EAAW;AACP,YAAI,KAAK7G,SAAL,KAAmB,KAAnB,IAA4B,KAAKG,sBAAL,KAAgC,KAAhE,EAAuE;AACnE,eAAKH,SAAL,GAAiB,IAAjB;AACA,eAAKM,UAAL,CAAgBE,QAAhB,GAA2B,IAA3B;AACH;;AAEDqG,QAAAA,IAAI,GAAG,KAAKlG,cAAL,GAAsB,EAA7B;AACAkG,QAAAA,IAAI,CAAC9E,IAAL,GAAY,OAAZ;AACA8E,QAAAA,IAAI,CAAC7E,EAAL,GAAU8E,KAAK,CAAC9E,EAAhB;AACA6E,QAAAA,IAAI,CAACE,SAAL,GAAiB,KAAKjG,UAAtB;AACA+F,QAAAA,IAAI,CAACzB,QAAL,GAAgB,KAAKrE,SAArB;AACH,OAXD,MAWO;AACH,YAAI,OAAO8F,IAAI,CAACgE,IAAZ,KAAqB,WAAzB,EAAsC;AAClC1M,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,EAAgB,8CAAhB;AACH;AACJ;;AAED,UAAI4L,OAAO,GAAGxH,CAAC,CAACI,QAAF,CAAW,CAAX,CAAd,CA5BmE,CA4BrC;;AAC9B,UAAIqH,UAAU,GAAGzH,CAAC,CAACI,QAAF,CAAW,CAAX,CAAjB,CA7BmE,CA6BlC;;AACjC,UAAIsH,oBAAoB,GAAG1H,CAAC,CAACI,QAAF,CAAW,CAAX,CAA3B,CA9BmE,CA8BxB;;AAC3C,UAAIuH,QAAQ,GAAG3H,CAAC,CAACI,QAAF,CAAW,CAAX,CAAf,CA/BmE,CA+BpC;;AAE/B,UAAIoH,OAAO,KAAK,CAAZ,IAAiBC,UAAU,KAAK,CAApC,EAAuC;AACnC,aAAK3L,QAAL,CAAcd,WAAW,CAACoI,YAA1B,EAAwC,4CAAxC;;AACA;AACH;;AAED,WAAK9F,eAAL,GAAuB,CAAC0C,CAAC,CAACI,QAAF,CAAW,CAAX,IAAgB,CAAjB,IAAsB,CAA7C,CAtCmE,CAsClB;;AACjD,UAAI,KAAK9C,eAAL,KAAyB,CAAzB,IAA8B,KAAKA,eAAL,KAAyB,CAA3D,EAA8D;AAAG;AAC7D,aAAKxB,QAAL,CAAcd,WAAW,CAACoI,YAA1B,iDAAgF,KAAK9F,eAAL,GAAuB,CAAvG;;AACA;AACH;;AAED,UAAIsK,QAAQ,GAAG5H,CAAC,CAACI,QAAF,CAAW,CAAX,IAAgB,EAA/B,CA5CmE,CA4C/B;;AACpC,UAAIwH,QAAQ,KAAK,CAAjB,EAAoB;AAChB,aAAK9L,QAAL,CAAcd,WAAW,CAACoI,YAA1B,EAAwC,oDAAxC;;AACA;AACH,OAHD,MAGO,IAAIwE,QAAQ,GAAG,CAAf,EAAkB;AACrB/M,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,oEAA2EgM,QAA3E;AACH;;AAED,UAAIjI,MAAM,GAAG,CAAb;;AAEA,WAAK,IAAIgD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,QAApB,EAA8BjF,CAAC,EAA/B,EAAmC;AAC/B,YAAIkF,GAAG,GAAG7H,CAAC,CAAC8H,SAAF,CAAYnI,MAAZ,EAAoB,CAACC,EAArB,CAAV,CAD+B,CACM;;AACrCD,QAAAA,MAAM,IAAI,CAAV;;AAEA,YAAIkI,GAAG,KAAK,CAAZ,EAAe;AACX;AACH,SAN8B,CAQ/B;;;AACA,YAAIE,GAAG,GAAG,IAAI3C,UAAJ,CAAenE,WAAf,EAA4B5E,UAAU,GAAGsD,MAAzC,EAAiDkI,GAAjD,CAAV;AACAlI,QAAAA,MAAM,IAAIkI,GAAV;AAEA,YAAIlM,MAAM,GAAGZ,SAAS,CAACiN,QAAV,CAAmBD,GAAnB,CAAb;;AACA,YAAIpF,CAAC,KAAK,CAAV,EAAa;AACT;AACA;AACH;;AAEDY,QAAAA,IAAI,CAAC0E,UAAL,GAAkBtM,MAAM,CAACuM,UAAP,CAAkBtG,KAApC;AACA2B,QAAAA,IAAI,CAAC4E,WAAL,GAAmBxM,MAAM,CAACuM,UAAP,CAAkBrG,MAArC;AACA0B,QAAAA,IAAI,CAAC6E,YAAL,GAAoBzM,MAAM,CAAC0M,YAAP,CAAoBzG,KAAxC;AACA2B,QAAAA,IAAI,CAAC+E,aAAL,GAAqB3M,MAAM,CAAC0M,YAAP,CAAoBxG,MAAzC;AAEA0B,QAAAA,IAAI,CAACgF,OAAL,GAAe5M,MAAM,CAAC6M,cAAtB;AACAjF,QAAAA,IAAI,CAACkF,KAAL,GAAa9M,MAAM,CAAC+M,YAApB;AACAnF,QAAAA,IAAI,CAACoF,QAAL,GAAgBhN,MAAM,CAACiN,SAAvB;AACArF,QAAAA,IAAI,CAACsF,YAAL,GAAoBlN,MAAM,CAACmN,aAA3B;AACAvF,QAAAA,IAAI,CAACwF,QAAL,GAAgBpN,MAAM,CAACqN,SAAvB;AACAzF,QAAAA,IAAI,CAAC0F,SAAL,GAAiBtN,MAAM,CAACuN,UAAxB;;AAEA,YAAIvN,MAAM,CAACuN,UAAP,CAAkBtL,KAAlB,KAA4B,KAA5B,IACAjC,MAAM,CAACuN,UAAP,CAAkBpL,OAAlB,KAA8B,CAD9B,IAEAnC,MAAM,CAACuN,UAAP,CAAkBnL,OAAlB,KAA8B,CAFlC,EAEqC;AACjCwF,UAAAA,IAAI,CAAC0F,SAAL,GAAiB,KAAKtL,mBAAtB;AACH;;AAED,YAAII,OAAO,GAAGwF,IAAI,CAAC0F,SAAL,CAAelL,OAA7B;AACA,YAAID,OAAO,GAAGyF,IAAI,CAAC0F,SAAL,CAAenL,OAA7B;AACAyF,QAAAA,IAAI,CAACc,iBAAL,GAAyBd,IAAI,CAACE,SAAL,IAAkB1F,OAAO,GAAGD,OAA5B,CAAzB;AAEA,YAAIqL,UAAU,GAAGpB,GAAG,CAACzC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAjB;AACA,YAAI8D,WAAW,GAAG,OAAlB;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AACxB,cAAIC,CAAC,GAAGH,UAAU,CAACE,CAAD,CAAV,CAAcE,QAAd,CAAuB,EAAvB,CAAR;;AACA,cAAID,CAAC,CAACzK,MAAF,GAAW,CAAf,EAAkB;AACdyK,YAAAA,CAAC,GAAG,MAAMA,CAAV;AACH;;AACDF,UAAAA,WAAW,IAAIE,CAAf;AACH;;AACD/F,QAAAA,IAAI,CAACY,KAAL,GAAaiF,WAAb;AAEA,YAAI9E,EAAE,GAAG,KAAKtH,UAAd;AACAsH,QAAAA,EAAE,CAAC1C,KAAH,GAAW2B,IAAI,CAAC0E,UAAhB;AACA3D,QAAAA,EAAE,CAACzC,MAAH,GAAY0B,IAAI,CAAC4E,WAAjB;AACA7D,QAAAA,EAAE,CAACzG,GAAH,GAAS0F,IAAI,CAAC0F,SAAL,CAAepL,GAAxB;AACAyG,QAAAA,EAAE,CAACiE,OAAH,GAAahF,IAAI,CAACgF,OAAlB;AACAjE,QAAAA,EAAE,CAACmE,KAAH,GAAWlF,IAAI,CAACkF,KAAhB;AACAnE,QAAAA,EAAE,CAACkF,SAAH,GAAe7N,MAAM,CAAC8N,UAAtB;AACAnF,QAAAA,EAAE,CAACuE,YAAH,GAAkBlN,MAAM,CAAC+N,oBAAzB;AACApF,QAAAA,EAAE,CAACqF,MAAH,GAAYpG,IAAI,CAACwF,QAAL,CAAcnH,KAA1B;AACA0C,QAAAA,EAAE,CAACsF,MAAH,GAAYrG,IAAI,CAACwF,QAAL,CAAclH,MAA1B;AACAyC,QAAAA,EAAE,CAACG,UAAH,GAAgB2E,WAAhB;;AAEA,YAAI9E,EAAE,CAACrH,QAAP,EAAiB;AACb,cAAIqH,EAAE,CAACC,UAAH,IAAiB,IAArB,EAA2B;AACvBD,YAAAA,EAAE,CAACI,QAAH,GAAc,0BAA0BJ,EAAE,CAACG,UAA7B,GAA0C,GAA1C,GAAgDH,EAAE,CAACC,UAAnD,GAAgE,GAA9E;AACH;AACJ,SAJD,MAIO;AACHD,UAAAA,EAAE,CAACI,QAAH,GAAc,0BAA0BJ,EAAE,CAACG,UAA7B,GAA0C,GAAxD;AACH;;AACD,YAAIH,EAAE,CAAC/B,UAAH,EAAJ,EAAqB;AACjB,eAAKxG,YAAL,CAAkBuI,EAAlB;AACH;AACJ;;AAED,UAAIuF,QAAQ,GAAG7J,CAAC,CAACI,QAAF,CAAWT,MAAX,CAAf,CAjImE,CAiI/B;;AACpC,UAAIkK,QAAQ,KAAK,CAAjB,EAAoB;AAChB,aAAK/N,QAAL,CAAcd,WAAW,CAACoI,YAA1B,EAAwC,oDAAxC;;AACA;AACH,OAHD,MAGO,IAAIyG,QAAQ,GAAG,CAAf,EAAkB;AACrBhP,QAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,oEAA2EiO,QAA3E;AACH;;AAEDlK,MAAAA,MAAM;;AAEN,WAAK,IAAIgD,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGkH,QAApB,EAA8BlH,EAAC,EAA/B,EAAmC;AAC/B,YAAIkF,IAAG,GAAG7H,CAAC,CAAC8H,SAAF,CAAYnI,MAAZ,EAAoB,CAACC,EAArB,CAAV,CAD+B,CACM;;;AACrCD,QAAAA,MAAM,IAAI,CAAV;;AAEA,YAAIkI,IAAG,KAAK,CAAZ,EAAe;AACX;AACH,SAN8B,CAQ/B;;;AACAlI,QAAAA,MAAM,IAAIkI,IAAV;AACH;;AAEDtE,MAAAA,IAAI,CAACgE,IAAL,GAAY,IAAInC,UAAJ,CAAe/E,QAAf,CAAZ;AACAkD,MAAAA,IAAI,CAACgE,IAAL,CAAUuC,GAAV,CAAc,IAAI1E,UAAJ,CAAenE,WAAf,EAA4B5E,UAA5B,EAAwCgE,QAAxC,CAAd,EAAiE,CAAjE;AACAxF,MAAAA,GAAG,CAACmF,CAAJ,CAAM,KAAKpE,GAAX,EAAgB,sCAAhB;;AAEA,UAAI,KAAKoF,4BAAL,EAAJ,EAAyC;AACrC;AACA,YAAI,KAAKzE,SAAL,KAAmB,KAAKuC,WAAL,CAAiBD,MAAjB,IAA2B,KAAKL,WAAL,CAAiBK,MAA/D,CAAJ,EAA4E;AACxE,eAAK1C,gBAAL,CAAsB,KAAK2C,WAA3B,EAAwC,KAAKN,WAA7C;AACH;AACJ,OALD,MAKO;AACH,aAAKzB,+BAAL,GAAuC,IAAvC;AACH,OAlKkE,CAmKnE;;;AACA,WAAKR,SAAL,GAAiB,KAAjB;;AACA,WAAKL,gBAAL,CAAsB,OAAtB,EAA+BqH,IAA/B;AACH;;;uCAEkBtC,W,EAAa5E,U,EAAYgE,Q,EAAUyC,Y,EAAcgE,W,EAAaE,S,EAAWI,G,EAAK;AAC7F,UAAIxH,EAAE,GAAG,KAAKb,aAAd;AACA,UAAIiB,CAAC,GAAG,IAAId,QAAJ,CAAa+B,WAAb,EAA0B5E,UAA1B,EAAsCgE,QAAtC,CAAR;AAEA,UAAI0J,KAAK,GAAG,EAAZ;AAAA,UAAgBlL,MAAM,GAAG,CAAzB;AAEA,UAAIc,MAAM,GAAG,CAAb;AACA,UAAMqK,UAAU,GAAG,KAAK1M,eAAxB;AACA,UAAIqH,GAAG,GAAG,KAAKpH,cAAL,GAAsBuF,YAAhC;AACA,UAAImH,QAAQ,GAAIjD,SAAS,KAAK,CAA9B,CAT6F,CAS1D;;AAEnC,aAAOrH,MAAM,GAAGU,QAAhB,EAA0B;AACtB,YAAIV,MAAM,GAAG,CAAT,IAAcU,QAAlB,EAA4B;AACxBxF,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,0CAAiD+I,GAAjD,wBAAkEhF,MAAlE,0BAAwFU,QAAxF;AACA,gBAFwB,CAEhB;AACX,SAJqB,CAKtB;;;AACA,YAAI6J,QAAQ,GAAGlK,CAAC,CAACE,SAAF,CAAYP,MAAZ,EAAoB,CAACC,EAArB,CAAf,CANsB,CAMoB;;AAC1C,YAAIoK,UAAU,KAAK,CAAnB,EAAsB;AAClBE,UAAAA,QAAQ,MAAM,CAAd;AACH;;AACD,YAAIA,QAAQ,GAAG7J,QAAQ,GAAG2J,UAA1B,EAAsC;AAClCnP,UAAAA,GAAG,CAACkF,CAAJ,CAAM,KAAKnE,GAAX,2CAAkD+I,GAAlD;AACA;AACH;;AAED,YAAIwF,QAAQ,GAAGnK,CAAC,CAACI,QAAF,CAAWT,MAAM,GAAGqK,UAApB,IAAkC,IAAjD;;AAEA,YAAIG,QAAQ,KAAK,CAAjB,EAAoB;AAAG;AACnBF,UAAAA,QAAQ,GAAG,IAAX;AACH;;AAED,YAAIhG,IAAI,GAAG,IAAImB,UAAJ,CAAenE,WAAf,EAA4B5E,UAAU,GAAGsD,MAAzC,EAAiDqK,UAAU,GAAGE,QAA9D,CAAX;AACA,YAAIrF,IAAI,GAAG;AAACpG,UAAAA,IAAI,EAAE0L,QAAP;AAAiBlG,UAAAA,IAAI,EAAEA;AAAvB,SAAX;AACA8F,QAAAA,KAAK,CAAClH,IAAN,CAAWgC,IAAX;AACAhG,QAAAA,MAAM,IAAIoF,IAAI,CAACpE,UAAf;AAEAF,QAAAA,MAAM,IAAIqK,UAAU,GAAGE,QAAvB;AACH;;AAED,UAAIH,KAAK,CAAClL,MAAV,EAAkB;AACd,YAAI2E,KAAK,GAAG,KAAKhF,WAAjB;AACA,YAAI4L,SAAS,GAAG;AACZL,UAAAA,KAAK,EAAEA,KADK;AAEZlL,UAAAA,MAAM,EAAEA,MAFI;AAGZwL,UAAAA,UAAU,EAAEJ,QAHA;AAIZtF,UAAAA,GAAG,EAAEA,GAJO;AAKZyC,UAAAA,GAAG,EAAEA,GALO;AAMZtC,UAAAA,GAAG,EAAGH,GAAG,GAAGyC;AANA,SAAhB;;AAQA,YAAI6C,QAAJ,EAAc;AACVG,UAAAA,SAAS,CAACE,YAAV,GAAyBxD,WAAzB;AACH;;AACDtD,QAAAA,KAAK,CAAC5E,OAAN,CAAciE,IAAd,CAAmBuH,SAAnB;AACA5G,QAAAA,KAAK,CAAC3E,MAAN,IAAgBA,MAAhB;AACH;AACJ;;;wBAp6BqB;AAClB,aAAO,KAAK3C,gBAAZ;AACH,K;sBAEmBqO,Q,EAAU;AAC1B,WAAKrO,gBAAL,GAAwBqO,QAAxB;AACH,K,CAED;;;;wBACkB;AACd,aAAO,KAAKxO,YAAZ;AACH,K;sBAEewO,Q,EAAU;AACtB,WAAKxO,YAAL,GAAoBwO,QAApB;AACH;;;wBAEuB;AACpB,aAAO,KAAKvO,kBAAZ;AACH,K;sBAEqBuO,Q,EAAU;AAC5B,WAAKvO,kBAAL,GAA0BuO,QAA1B;AACH;;;wBAEyB;AACtB,aAAO,KAAKtO,oBAAZ;AACH,K;sBAEuBsO,Q,EAAU;AAC9B,WAAKtO,oBAAL,GAA4BsO,QAA5B;AACH,K,CAED;;;;wBACc;AACV,aAAO,KAAKzO,QAAZ;AACH,K;sBAEWyO,Q,EAAU;AAClB,WAAKzO,QAAL,GAAgByO,QAAhB;AACH,K,CAED;;;;wBACsB;AAClB,aAAO,KAAKpO,gBAAZ;AACH,K;sBAEmBoO,Q,EAAU;AAC1B,WAAKpO,gBAAL,GAAwBoO,QAAxB;AACH,K,CAED;;;;wBACoB;AAChB,aAAO,KAAKhN,cAAZ;AACH,K;sBAEiBiN,I,EAAM;AACpB,WAAKjN,cAAL,GAAsBiN,IAAtB;AACH;;;wBAEuB;AACpB,aAAO,KAAK/M,SAAZ;AACH,K,CAED;;sBACsBqE,Q,EAAU;AAC5B,WAAKpE,kBAAL,GAA0B,IAA1B;AACA,WAAKD,SAAL,GAAiBqE,QAAjB;AACA,WAAK9E,UAAL,CAAgB8E,QAAhB,GAA2BA,QAA3B;AACH,K,CAED;;;;sBACsB7E,Q,EAAU;AAC5B,WAAKL,sBAAL,GAA8B,IAA9B;AACA,WAAKJ,SAAL,GAAiBS,QAAjB;AACA,WAAKD,UAAL,CAAgBC,QAAhB,GAA2BA,QAA3B;AACH,K,CAED;;;;sBACsBC,Q,EAAU;AAC5B,WAAKL,sBAAL,GAA8B,IAA9B;AACA,WAAKH,SAAL,GAAiBQ,QAAjB;AACA,WAAKF,UAAL,CAAgBE,QAAhB,GAA2BA,QAA3B;AACH;;;0BAnHYuN,M,EAAQ;AACjB,UAAIxG,IAAI,GAAG,IAAImB,UAAJ,CAAeqF,MAAf,CAAX;AACA,UAAIC,QAAQ,GAAG;AAACC,QAAAA,KAAK,EAAE;AAAR,OAAf;;AAEA,UAAI1G,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAZ,IAAoBA,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAhC,IAAwCA,IAAI,CAAC,CAAD,CAAJ,KAAY,IAApD,IAA4DA,IAAI,CAAC,CAAD,CAAJ,KAAY,IAA5E,EAAkF;AAC9E,eAAOyG,QAAP;AACH;;AAED,UAAIzN,QAAQ,GAAI,CAACgH,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAX,MAAkB,CAAnB,KAA0B,CAAzC;AACA,UAAI/G,QAAQ,GAAG,CAAC+G,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAX,MAAkB,CAAjC;AAEA,UAAItE,MAAM,GAAGrE,SAAS,CAAC2I,IAAD,EAAO,CAAP,CAAtB;;AAEA,UAAItE,MAAM,GAAG,CAAb,EAAgB;AACZ,eAAO+K,QAAP;AACH;;AAED,aAAO;AACHC,QAAAA,KAAK,EAAE,IADJ;AAEHC,QAAAA,QAAQ,EAAEjL,MAFP;AAGHtD,QAAAA,UAAU,EAAEsD,MAHT;AAIHlD,QAAAA,aAAa,EAAEQ,QAJZ;AAKHN,QAAAA,aAAa,EAAEO;AALZ,OAAP;AAOH;;;;;;AAg7BL,eAAezB,UAAf","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport AMF from './amf-parser.js';\nimport SPSParser from './sps-parser.js';\nimport DemuxErrors from './demux-errors.js';\nimport MediaInfo from '../core/media-info.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\nfunction Swap16(src) {\n    return (((src >>> 8) & 0xFF) |\n            ((src & 0xFF) << 8));\n}\n\nfunction Swap32(src) {\n    return (((src & 0xFF000000) >>> 24) |\n            ((src & 0x00FF0000) >>> 8)  |\n            ((src & 0x0000FF00) << 8)   |\n            ((src & 0x000000FF) << 24));\n}\n\nfunction ReadBig32(array, index) {\n    return ((array[index] << 24)     |\n            (array[index + 1] << 16) |\n            (array[index + 2] << 8)  |\n            (array[index + 3]));\n}\n\n\nclass FLVDemuxer {\n\n    constructor(probeData, config) {\n        this.TAG = 'FLVDemuxer';\n\n        this._config = config;\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onMetaDataArrived = null;\n        this._onScriptDataArrived = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n\n        this._dataOffset = probeData.dataOffset;\n        this._firstParse = true;\n        this._dispatch = false;\n\n        this._hasAudio = probeData.hasAudioTrack;\n        this._hasVideo = probeData.hasVideoTrack;\n\n        this._hasAudioFlagOverrided = false;\n        this._hasVideoFlagOverrided = false;\n\n        this._audioInitialMetadataDispatched = false;\n        this._videoInitialMetadataDispatched = false;\n\n        this._mediaInfo = new MediaInfo();\n        this._mediaInfo.hasAudio = this._hasAudio;\n        this._mediaInfo.hasVideo = this._hasVideo;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n\n        this._naluLengthSize = 4;\n        this._timestampBase = 0;  // int32, in milliseconds\n        this._timescale = 1000;\n        this._duration = 0;  // int32, in milliseconds\n        this._durationOverrided = false;\n        this._referenceFrameRate = {\n            fixed: true,\n            fps: 23.976,\n            fps_num: 23976,\n            fps_den: 1000\n        };\n\n        this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n\n        this._mpegSamplingRates = [\n            96000, 88200, 64000, 48000, 44100, 32000,\n            24000, 22050, 16000, 12000, 11025, 8000, 7350\n        ];\n\n        this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n        this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n        this._mpegAudioV25SampleRateTable = [11025, 12000, 8000,  0];\n\n        this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n        this._mpegAudioL2BitRateTable = [0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n        this._mpegAudioL3BitRateTable = [0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, -1];\n\n        this._videoTrack = {type: 'video', id: 1, sequenceNumber: 0, samples: [], length: 0};\n        this._audioTrack = {type: 'audio', id: 2, sequenceNumber: 0, samples: [], length: 0};\n\n        this._littleEndian = (function () {\n            let buf = new ArrayBuffer(2);\n            (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\n            return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\n        })();\n    }\n\n    destroy() {\n        this._mediaInfo = null;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n        this._videoTrack = null;\n        this._audioTrack = null;\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onMetaDataArrived = null;\n        this._onScriptDataArrived = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n    }\n\n    static probe(buffer) {\n        let data = new Uint8Array(buffer);\n        let mismatch = {match: false};\n\n        if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n            return mismatch;\n        }\n\n        let hasAudio = ((data[4] & 4) >>> 2) !== 0;\n        let hasVideo = (data[4] & 1) !== 0;\n\n        let offset = ReadBig32(data, 5);\n\n        if (offset < 9) {\n            return mismatch;\n        }\n\n        return {\n            match: true,\n            consumed: offset,\n            dataOffset: offset,\n            hasAudioTrack: hasAudio,\n            hasVideoTrack: hasVideo\n        };\n    }\n\n    bindDataSource(loader) {\n        loader.onDataArrival = this.parseChunks.bind(this);\n        return this;\n    }\n\n    // prototype: function(type: string, metadata: any): void\n    get onTrackMetadata() {\n        return this._onTrackMetadata;\n    }\n\n    set onTrackMetadata(callback) {\n        this._onTrackMetadata = callback;\n    }\n\n    // prototype: function(mediaInfo: MediaInfo): void\n    get onMediaInfo() {\n        return this._onMediaInfo;\n    }\n\n    set onMediaInfo(callback) {\n        this._onMediaInfo = callback;\n    }\n\n    get onMetaDataArrived() {\n        return this._onMetaDataArrived;\n    }\n\n    set onMetaDataArrived(callback) {\n        this._onMetaDataArrived = callback;\n    }\n\n    get onScriptDataArrived() {\n        return this._onScriptDataArrived;\n    }\n\n    set onScriptDataArrived(callback) {\n        this._onScriptDataArrived = callback;\n    }\n\n    // prototype: function(type: number, info: string): void\n    get onError() {\n        return this._onError;\n    }\n\n    set onError(callback) {\n        this._onError = callback;\n    }\n\n    // prototype: function(videoTrack: any, audioTrack: any): void\n    get onDataAvailable() {\n        return this._onDataAvailable;\n    }\n\n    set onDataAvailable(callback) {\n        this._onDataAvailable = callback;\n    }\n\n    // timestamp base for output samples, must be in milliseconds\n    get timestampBase() {\n        return this._timestampBase;\n    }\n\n    set timestampBase(base) {\n        this._timestampBase = base;\n    }\n\n    get overridedDuration() {\n        return this._duration;\n    }\n\n    // Force-override media duration. Must be in milliseconds, int32\n    set overridedDuration(duration) {\n        this._durationOverrided = true;\n        this._duration = duration;\n        this._mediaInfo.duration = duration;\n    }\n\n    // Force-override audio track present flag, boolean\n    set overridedHasAudio(hasAudio) {\n        this._hasAudioFlagOverrided = true;\n        this._hasAudio = hasAudio;\n        this._mediaInfo.hasAudio = hasAudio;\n    }\n\n    // Force-override video track present flag, boolean\n    set overridedHasVideo(hasVideo) {\n        this._hasVideoFlagOverrided = true;\n        this._hasVideo = hasVideo;\n        this._mediaInfo.hasVideo = hasVideo;\n    }\n\n    resetMediaInfo() {\n        this._mediaInfo = new MediaInfo();\n    }\n\n    _isInitialMetadataDispatched() {\n        if (this._hasAudio && this._hasVideo) {  // both audio & video\n            return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n        }\n        if (this._hasAudio && !this._hasVideo) {  // audio only\n            return this._audioInitialMetadataDispatched;\n        }\n        if (!this._hasAudio && this._hasVideo) {  // video only\n            return this._videoInitialMetadataDispatched;\n        }\n        return false;\n    }\n\n    // function parseChunks(chunk: ArrayBuffer, byteStart: number): number;\n    parseChunks(chunk, byteStart) {\n        if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n            throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n        }\n\n        let offset = 0;\n        let le = this._littleEndian;\n\n        if (byteStart === 0) {  // buffer with FLV header\n            if (chunk.byteLength > 13) {\n                let probeData = FLVDemuxer.probe(chunk);\n                offset = probeData.dataOffset;\n            } else {\n                return 0;\n            }\n        }\n\n        if (this._firstParse) {  // handle PreviousTagSize0 before Tag1\n            this._firstParse = false;\n            if (byteStart + offset !== this._dataOffset) {\n                Log.w(this.TAG, 'First time parsing but chunk byteStart invalid!');\n            }\n\n            let v = new DataView(chunk, offset);\n            let prevTagSize0 = v.getUint32(0, !le);\n            if (prevTagSize0 !== 0) {\n                Log.w(this.TAG, 'PrevTagSize0 !== 0 !!!');\n            }\n            offset += 4;\n        }\n\n        while (offset < chunk.byteLength) {\n            this._dispatch = true;\n\n            let v = new DataView(chunk, offset);\n\n            if (offset + 11 + 4 > chunk.byteLength) {\n                // data not enough for parsing an flv tag\n                break;\n            }\n\n            let tagType = v.getUint8(0);\n            let dataSize = v.getUint32(0, !le) & 0x00FFFFFF;\n\n            if (offset + 11 + dataSize + 4 > chunk.byteLength) {\n                // data not enough for parsing actual data body\n                break;\n            }\n\n            if (tagType !== 8 && tagType !== 9 && tagType !== 18) {\n                Log.w(this.TAG, `Unsupported tag type ${tagType}, skipped`);\n                // consume the whole tag (skip it)\n                offset += 11 + dataSize + 4;\n                continue;\n            }\n\n            let ts2 = v.getUint8(4);\n            let ts1 = v.getUint8(5);\n            let ts0 = v.getUint8(6);\n            let ts3 = v.getUint8(7);\n\n            let timestamp = ts0 | (ts1 << 8) | (ts2 << 16) | (ts3 << 24);\n\n            let streamId = v.getUint32(7, !le) & 0x00FFFFFF;\n            if (streamId !== 0) {\n                Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n            }\n\n            let dataOffset = offset + 11;\n\n            switch (tagType) {\n                case 8:  // Audio\n                    this._parseAudioData(chunk, dataOffset, dataSize, timestamp);\n                    break;\n                case 9:  // Video\n                    this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);\n                    break;\n                case 18:  // ScriptDataObject\n                    this._parseScriptData(chunk, dataOffset, dataSize);\n                    break;\n            }\n\n            let prevTagSize = v.getUint32(11 + dataSize, !le);\n            if (prevTagSize !== 11 + dataSize) {\n                Log.w(this.TAG, `Invalid PrevTagSize ${prevTagSize}`);\n            }\n\n            offset += 11 + dataSize + 4;  // tagBody + dataSize + prevTagSize\n        }\n\n        // dispatch parsed frames to consumer (typically, the remuxer)\n        if (this._isInitialMetadataDispatched()) {\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        }\n\n        return offset;  // consumed bytes, just equals latest offset index\n    }\n\n    _parseScriptData(arrayBuffer, dataOffset, dataSize) {\n        let scriptData = AMF.parseScriptData(arrayBuffer, dataOffset, dataSize);\n\n        if (scriptData.hasOwnProperty('onMetaData')) {\n            if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n                Log.w(this.TAG, 'Invalid onMetaData structure!');\n                return;\n            }\n            if (this._metadata) {\n                Log.w(this.TAG, 'Found another onMetaData tag!');\n            }\n            this._metadata = scriptData;\n            let onMetaData = this._metadata.onMetaData;\n\n            if (this._onMetaDataArrived) {\n                this._onMetaDataArrived(Object.assign({}, onMetaData));\n            }\n\n            if (typeof onMetaData.hasAudio === 'boolean') {  // hasAudio\n                if (this._hasAudioFlagOverrided === false) {\n                    this._hasAudio = onMetaData.hasAudio;\n                    this._mediaInfo.hasAudio = this._hasAudio;\n                }\n            }\n            if (typeof onMetaData.hasVideo === 'boolean') {  // hasVideo\n                if (this._hasVideoFlagOverrided === false) {\n                    this._hasVideo = onMetaData.hasVideo;\n                    this._mediaInfo.hasVideo = this._hasVideo;\n                }\n            }\n            if (typeof onMetaData.audiodatarate === 'number') {  // audiodatarate\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n            }\n            if (typeof onMetaData.videodatarate === 'number') {  // videodatarate\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n            }\n            if (typeof onMetaData.width === 'number') {  // width\n                this._mediaInfo.width = onMetaData.width;\n            }\n            if (typeof onMetaData.height === 'number') {  // height\n                this._mediaInfo.height = onMetaData.height;\n            }\n            if (typeof onMetaData.duration === 'number') {  // duration\n                if (!this._durationOverrided) {\n                    let duration = Math.floor(onMetaData.duration * this._timescale);\n                    this._duration = duration;\n                    this._mediaInfo.duration = duration;\n                }\n            } else {\n                this._mediaInfo.duration = 0;\n            }\n            if (typeof onMetaData.framerate === 'number') {  // framerate\n                let fps_num = Math.floor(onMetaData.framerate * 1000);\n                if (fps_num > 0) {\n                    let fps = fps_num / 1000;\n                    this._referenceFrameRate.fixed = true;\n                    this._referenceFrameRate.fps = fps;\n                    this._referenceFrameRate.fps_num = fps_num;\n                    this._referenceFrameRate.fps_den = 1000;\n                    this._mediaInfo.fps = fps;\n                }\n            }\n            if (typeof onMetaData.keyframes === 'object') {  // keyframes\n                this._mediaInfo.hasKeyframesIndex = true;\n                let keyframes = onMetaData.keyframes;\n                this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n                onMetaData.keyframes = null;  // keyframes has been extracted, remove it\n            } else {\n                this._mediaInfo.hasKeyframesIndex = false;\n            }\n            this._dispatch = false;\n            this._mediaInfo.metadata = onMetaData;\n            Log.v(this.TAG, 'Parsed onMetaData');\n            if (this._mediaInfo.isComplete()) {\n                this._onMediaInfo(this._mediaInfo);\n            }\n        }\n\n        if (Object.keys(scriptData).length > 0) {\n            if (this._onScriptDataArrived) {\n                this._onScriptDataArrived(Object.assign({}, scriptData));\n            }\n        }\n    }\n\n    _parseKeyframesIndex(keyframes) {\n        let times = [];\n        let filepositions = [];\n\n        // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n        for (let i = 1; i < keyframes.times.length; i++) {\n            let time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n            times.push(time);\n            filepositions.push(keyframes.filepositions[i]);\n        }\n\n        return {\n            times: times,\n            filepositions: filepositions\n        };\n    }\n\n    _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n        if (dataSize <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n\n        if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n            // If hasAudio: false indicated explicitly in MediaDataSource,\n            // Ignore all the audio packets\n            return;\n        }\n\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let soundSpec = v.getUint8(0);\n\n        let soundFormat = soundSpec >>> 4;\n        if (soundFormat !== 2 && soundFormat !== 10) {  // MP3 or AAC\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n            return;\n        }\n\n        let soundRate = 0;\n        let soundRateIndex = (soundSpec & 12) >>> 2;\n        if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n            soundRate = this._flvSoundRateTable[soundRateIndex];\n        } else {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n            return;\n        }\n\n        let soundSize = (soundSpec & 2) >>> 1;  // unused\n        let soundType = (soundSpec & 1);\n\n\n        let meta = this._audioMetadata;\n        let track = this._audioTrack;\n\n        if (!meta) {\n            if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n                this._hasAudio = true;\n                this._mediaInfo.hasAudio = true;\n            }\n\n            // initial metadata\n            meta = this._audioMetadata = {};\n            meta.type = 'audio';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n            meta.audioSampleRate = soundRate;\n            meta.channelCount = (soundType === 0 ? 1 : 2);\n        }\n\n        if (soundFormat === 10) {  // AAC\n            let aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n            if (aacData == undefined) {\n                return;\n            }\n\n            if (aacData.packetType === 0) {  // AAC sequence header (AudioSpecificConfig)\n                if (meta.config) {\n                    Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n                }\n                let misc = aacData.data;\n                meta.audioSampleRate = misc.samplingRate;\n                meta.channelCount = misc.channelCount;\n                meta.codec = misc.codec;\n                meta.originalCodec = misc.originalCodec;\n                meta.config = misc.config;\n                // The decode result of an aac sample is 1024 PCM samples\n                meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n                Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n                if (this._isInitialMetadataDispatched()) {\n                    // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n                    if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                        this._onDataAvailable(this._audioTrack, this._videoTrack);\n                    }\n                } else {\n                    this._audioInitialMetadataDispatched = true;\n                }\n                // then notify new metadata\n                this._dispatch = false;\n                this._onTrackMetadata('audio', meta);\n\n                let mi = this._mediaInfo;\n                mi.audioCodec = meta.originalCodec;\n                mi.audioSampleRate = meta.audioSampleRate;\n                mi.audioChannelCount = meta.channelCount;\n                if (mi.hasVideo) {\n                    if (mi.videoCodec != null) {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                    }\n                } else {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                }\n                if (mi.isComplete()) {\n                    this._onMediaInfo(mi);\n                }\n            } else if (aacData.packetType === 1) {  // AAC raw frame data\n                let dts = this._timestampBase + tagTimestamp;\n                let aacSample = {unit: aacData.data, length: aacData.data.byteLength, dts: dts, pts: dts};\n                track.samples.push(aacSample);\n                track.length += aacData.data.length;\n            } else {\n                Log.e(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\n            }\n        } else if (soundFormat === 2) {  // MP3\n            if (!meta.codec) {\n                // We need metadata for mp3 audio track, extract info from frame header\n                let misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);\n                if (misc == undefined) {\n                    return;\n                }\n                meta.audioSampleRate = misc.samplingRate;\n                meta.channelCount = misc.channelCount;\n                meta.codec = misc.codec;\n                meta.originalCodec = misc.originalCodec;\n                // The decode result of an mp3 sample is 1152 PCM samples\n                meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n                Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n\n                this._audioInitialMetadataDispatched = true;\n                this._onTrackMetadata('audio', meta);\n\n                let mi = this._mediaInfo;\n                mi.audioCodec = meta.codec;\n                mi.audioSampleRate = meta.audioSampleRate;\n                mi.audioChannelCount = meta.channelCount;\n                mi.audioDataRate = misc.bitRate;\n                if (mi.hasVideo) {\n                    if (mi.videoCodec != null) {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                    }\n                } else {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                }\n                if (mi.isComplete()) {\n                    this._onMediaInfo(mi);\n                }\n            }\n\n            // This packet is always a valid audio packet, extract it\n            let data = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);\n            if (data == undefined) {\n                return;\n            }\n            let dts = this._timestampBase + tagTimestamp;\n            let mp3Sample = {unit: data, length: data.byteLength, dts: dts, pts: dts};\n            track.samples.push(mp3Sample);\n            track.length += data.length;\n        }\n    }\n\n    _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n            return;\n        }\n\n        let result = {};\n        let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n\n        result.packetType = array[0];\n\n        if (array[0] === 0) {\n            result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n        } else {\n            result.data = array.subarray(1);\n        }\n\n        return result;\n    }\n\n    _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n        let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n        let config = null;\n\n        /* Audio Object Type:\n           0: Null\n           1: AAC Main\n           2: AAC LC\n           3: AAC SSR (Scalable Sample Rate)\n           4: AAC LTP (Long Term Prediction)\n           5: HE-AAC / SBR (Spectral Band Replication)\n           6: AAC Scalable\n        */\n\n        let audioObjectType = 0;\n        let originalAudioObjectType = 0;\n        let audioExtensionObjectType = null;\n        let samplingIndex = 0;\n        let extensionSamplingIndex = null;\n\n        // 5 bits\n        audioObjectType = originalAudioObjectType = array[0] >>> 3;\n        // 4 bits\n        samplingIndex = ((array[0] & 0x07) << 1) | (array[1] >>> 7);\n        if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n            return;\n        }\n\n        let samplingFrequence = this._mpegSamplingRates[samplingIndex];\n\n        // 4 bits\n        let channelConfig = (array[1] & 0x78) >>> 3;\n        if (channelConfig < 0 || channelConfig >= 8) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n            return;\n        }\n\n        if (audioObjectType === 5) {  // HE-AAC?\n            // 4 bits\n            extensionSamplingIndex = ((array[1] & 0x07) << 1) | (array[2] >>> 7);\n            // 5 bits\n            audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n        }\n\n        // workarounds for various browsers\n        let userAgent = self.navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf('firefox') !== -1) {\n            // firefox: use SBR (HE-AAC) if freq less than 24kHz\n            if (samplingIndex >= 6) {\n                audioObjectType = 5;\n                config = new Array(4);\n                extensionSamplingIndex = samplingIndex - 3;\n            } else {  // use LC-AAC\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        } else if (userAgent.indexOf('android') !== -1) {\n            // android: always use LC-AAC\n            audioObjectType = 2;\n            config = new Array(2);\n            extensionSamplingIndex = samplingIndex;\n        } else {\n            // for other browsers, e.g. chrome...\n            // Always use HE-AAC to make it easier to switch aac codec profile\n            audioObjectType = 5;\n            extensionSamplingIndex = samplingIndex;\n            config = new Array(4);\n\n            if (samplingIndex >= 6) {\n                extensionSamplingIndex = samplingIndex - 3;\n            } else if (channelConfig === 1) {  // Mono channel\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        }\n\n        config[0]  = audioObjectType << 3;\n        config[0] |= (samplingIndex & 0x0F) >>> 1;\n        config[1]  = (samplingIndex & 0x0F) << 7;\n        config[1] |= (channelConfig & 0x0F) << 3;\n        if (audioObjectType === 5) {\n            config[1] |= ((extensionSamplingIndex & 0x0F) >>> 1);\n            config[2]  = (extensionSamplingIndex & 0x01) << 7;\n            // extended audio object type: force to 2 (LC-AAC)\n            config[2] |= (2 << 2);\n            config[3]  = 0;\n        }\n\n        return {\n            config: config,\n            samplingRate: samplingFrequence,\n            channelCount: channelConfig,\n            codec: 'mp4a.40.' + audioObjectType,\n            originalCodec: 'mp4a.40.' + originalAudioObjectType\n        };\n    }\n\n    _parseMP3AudioData(arrayBuffer, dataOffset, dataSize, requestHeader) {\n        if (dataSize < 4) {\n            Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n            return;\n        }\n\n        let le = this._littleEndian;\n        let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n        let result = null;\n\n        if (requestHeader) {\n            if (array[0] !== 0xFF) {\n                return;\n            }\n            let ver = (array[1] >>> 3) & 0x03;\n            let layer = (array[1] & 0x06) >> 1;\n\n            let bitrate_index = (array[2] & 0xF0) >>> 4;\n            let sampling_freq_index = (array[2] & 0x0C) >>> 2;\n\n            let channel_mode = (array[3] >>> 6) & 0x03;\n            let channel_count = channel_mode !== 3 ? 2 : 1;\n\n            let sample_rate = 0;\n            let bit_rate = 0;\n            let object_type = 34;  // Layer-3, listed in MPEG-4 Audio Object Types\n\n            let codec = 'mp3';\n\n            switch (ver) {\n                case 0:  // MPEG 2.5\n                    sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n                    break;\n                case 2:  // MPEG 2\n                    sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n                    break;\n                case 3:  // MPEG 1\n                    sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n                    break;\n            }\n\n            switch (layer) {\n                case 1:  // Layer 3\n                    object_type = 34;\n                    if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n                        bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n                    }\n                    break;\n                case 2:  // Layer 2\n                    object_type = 33;\n                    if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n                        bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n                    }\n                    break;\n                case 3:  // Layer 1\n                    object_type = 32;\n                    if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n                        bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n                    }\n                    break;\n            }\n\n            result = {\n                bitRate: bit_rate,\n                samplingRate: sample_rate,\n                channelCount: channel_count,\n                codec: codec,\n                originalCodec: codec\n            };\n        } else {\n            result = array;\n        }\n\n        return result;\n    }\n\n    _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n        if (dataSize <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n            return;\n        }\n\n        if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n            // If hasVideo: false indicated explicitly in MediaDataSource,\n            // Ignore all the video packets\n            return;\n        }\n\n        let spec = (new Uint8Array(arrayBuffer, dataOffset, dataSize))[0];\n\n        let frameType = (spec & 240) >>> 4;\n        let codecId = spec & 15;\n\n        if (codecId !== 7) {\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, `Flv: Unsupported codec in video frame: ${codecId}`);\n            return;\n        }\n\n        this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n    }\n\n    _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n        if (dataSize < 4) {\n            Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n            return;\n        }\n\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let packetType = v.getUint8(0);\n        let cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n        let cts = (cts_unsigned << 8) >> 8;  // convert to 24-bit signed int\n\n        if (packetType === 0) {  // AVCDecoderConfigurationRecord\n            this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n        } else if (packetType === 1) {  // One or more Nalus\n            this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid video packet type ${packetType}`);\n            return;\n        }\n    }\n\n    _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 7) {\n            Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n            return;\n        }\n\n        let meta = this._videoMetadata;\n        let track = this._videoTrack;\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        if (!meta) {\n            if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n                this._hasVideo = true;\n                this._mediaInfo.hasVideo = true;\n            }\n\n            meta = this._videoMetadata = {};\n            meta.type = 'video';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n        } else {\n            if (typeof meta.avcc !== 'undefined') {\n                Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n            }\n        }\n\n        let version = v.getUint8(0);  // configurationVersion\n        let avcProfile = v.getUint8(1);  // avcProfileIndication\n        let profileCompatibility = v.getUint8(2);  // profile_compatibility\n        let avcLevel = v.getUint8(3);  // AVCLevelIndication\n\n        if (version !== 1 || avcProfile === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1;  // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {  // holy shit!!!\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\n            return;\n        }\n\n        let spsCount = v.getUint8(5) & 31;  // numOfSequenceParameterSets\n        if (spsCount === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n            return;\n        } else if (spsCount > 1) {\n            Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ${spsCount}`);\n        }\n\n        let offset = 6;\n\n        for (let i = 0; i < spsCount; i++) {\n            let len = v.getUint16(offset, !le);  // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            let sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            offset += len;\n\n            let config = SPSParser.parseSPS(sps);\n            if (i !== 0) {\n                // ignore other sps's config\n                continue;\n            }\n\n            meta.codecWidth = config.codec_size.width;\n            meta.codecHeight = config.codec_size.height;\n            meta.presentWidth = config.present_size.width;\n            meta.presentHeight = config.present_size.height;\n\n            meta.profile = config.profile_string;\n            meta.level = config.level_string;\n            meta.bitDepth = config.bit_depth;\n            meta.chromaFormat = config.chroma_format;\n            meta.sarRatio = config.sar_ratio;\n            meta.frameRate = config.frame_rate;\n\n            if (config.frame_rate.fixed === false ||\n                config.frame_rate.fps_num === 0 ||\n                config.frame_rate.fps_den === 0) {\n                meta.frameRate = this._referenceFrameRate;\n            }\n\n            let fps_den = meta.frameRate.fps_den;\n            let fps_num = meta.frameRate.fps_num;\n            meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n\n            let codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n            meta.codec = codecString;\n\n            let mi = this._mediaInfo;\n            mi.width = meta.codecWidth;\n            mi.height = meta.codecHeight;\n            mi.fps = meta.frameRate.fps;\n            mi.profile = meta.profile;\n            mi.level = meta.level;\n            mi.refFrames = config.ref_frames;\n            mi.chromaFormat = config.chroma_format_string;\n            mi.sarNum = meta.sarRatio.width;\n            mi.sarDen = meta.sarRatio.height;\n            mi.videoCodec = codecString;\n\n            if (mi.hasAudio) {\n                if (mi.audioCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n        }\n\n        let ppsCount = v.getUint8(offset);  // numOfPictureParameterSets\n        if (ppsCount === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n            return;\n        } else if (ppsCount > 1) {\n            Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ${ppsCount}`);\n        }\n\n        offset++;\n\n        for (let i = 0; i < ppsCount; i++) {\n            let len = v.getUint16(offset, !le);  // pictureParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // pps is useless for extracting video information\n            offset += len;\n        }\n\n        meta.avcc = new Uint8Array(dataSize);\n        meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n        Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n        if (this._isInitialMetadataDispatched()) {\n            // flush parsed frames\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        } else {\n            this._videoInitialMetadataDispatched = true;\n        }\n        // notify new metadata\n        this._dispatch = false;\n        this._onTrackMetadata('video', meta);\n    }\n\n    _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let units = [], length = 0;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        let dts = this._timestampBase + tagTimestamp;\n        let keyframe = (frameType === 1);  // from FLV Frame Type constants\n\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                Log.w(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break;  // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset, !le);  // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                Log.w(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n\n            let unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n            if (unitType === 5) {  // IDR\n                keyframe = true;\n            }\n\n            let data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n            let unit = {type: unitType, data: data};\n            units.push(unit);\n            length += data.byteLength;\n\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            let track = this._videoTrack;\n            let avcSample = {\n                units: units,\n                length: length,\n                isKeyframe: keyframe,\n                dts: dts,\n                cts: cts,\n                pts: (dts + cts)\n            };\n            if (keyframe) {\n                avcSample.fileposition = tagPosition;\n            }\n            track.samples.push(avcSample);\n            track.length += length;\n        }\n    }\n\n}\n\nexport default FLVDemuxer;"]},"metadata":{},"sourceType":"module"}